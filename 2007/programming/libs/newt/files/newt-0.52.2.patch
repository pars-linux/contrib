diff -Naur newt-0.52.2.orig/checkboxtree.c newt-0.52.2/checkboxtree.c
--- newt-0.52.2.orig/checkboxtree.c	2005-09-30 17:05:55.000000000 +0300
+++ newt-0.52.2/checkboxtree.c	2007-03-26 21:16:24.000000000 +0300
@@ -25,6 +25,7 @@
     int sbAdjust;
     int curWidth;
     int userHasSetWidth;
+    int isActive;
     char * seq;
     char * result;
 };
@@ -333,12 +334,15 @@
     ct = malloc(sizeof(struct CheckboxTree));
     co->callback = NULL;
     co->data = ct;
+    co->left = left;
+    co->top = top;
     co->ops = &ctOps;
     co->takesFocus = 1;
     co->height = height;
     co->width = 0;
     co->isMapped = 0;
     ct->curWidth = 0;
+    ct->isActive = 0;
     ct->userHasSetWidth = 0;
     ct->itemlist = NULL;
     ct->firstItem = NULL;
@@ -460,12 +464,7 @@
     
     while (*item && i < co->height) {
 	newtGotorc(co->top + i, co->left);
-	if (*item == *ct->currItem) {
-	    SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
-	    currRow = co->top + i;
-	} else
-	    SLsmg_set_color(NEWT_COLORSET_LISTBOX);
-
+	SLsmg_set_color(NEWT_COLORSET_LISTBOX);
 	for (j = 0; j < (*item)->depth; j++)
 	    SLsmg_write_string("   ");
 
@@ -477,7 +476,7 @@
 	} else {
 	    if (ct->flags & NEWT_CHECKBOXTREE_HIDE_BOX) {
 		if ((*item)->selected)
-		    SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
+		    SLsmg_set_color(NEWT_COLORSET_SELLISTBOX);
 	        SLsmg_write_string("    ");
 	    } else {
 	        char tmp[5];
@@ -486,8 +485,17 @@
 	    }
 	}
 
-	SLsmg_write_nstring((*item)->text, co->width - 4 - 
-					   (3 * (*item)->depth));
+	j = 4 + (3 * (*item)->depth);
+	SLsmg_write_nstring(NULL, co->width - j);
+	newtGotorc(co->top + i, co->left + j);
+	if (wstrlen((*item)->text, -1) > co->width - j) {
+	    char *tmp;
+	    tmp = strdup((*item)->text);
+	    trim_string(tmp, co->width - j);
+	    SLsmg_write_string(tmp);
+	    free(tmp);
+	} else
+	    SLsmg_write_string((*item)->text);
 
 	SLsmg_set_color(NEWT_COLORSET_LISTBOX);
 
@@ -536,6 +544,18 @@
     free(co);
 }
 
+static void ctEnsureLimits( struct CheckboxTree *ct ) {
+    struct items **listEnd = ct->flatList + ct->flatCount - 1;
+    if (ct->firstItem < ct->flatList)
+        ct->firstItem = ct->flatList;
+    if (ct->currItem < ct->flatList)
+        ct->currItem = ct->flatList;
+    if (ct->firstItem > listEnd) {
+        ct->firstItem = listEnd;
+        ct->currItem = listEnd;
+    }
+}
+
 struct eventResult ctEvent(newtComponent co, struct event ev) {
     struct CheckboxTree * ct = co->data;
     struct eventResult er;
@@ -647,6 +667,7 @@
 		ct->currItem -= co->height;
 		ct->firstItem -= co->height;
 	    }
+	    ctEnsureLimits( ct );
 
 	    ctDraw(co);
 	    if(co->callback) co->callback(co, co->callbackData);
@@ -663,6 +684,7 @@
 	    	ct->currItem += co->height;
 		ct->firstItem += co->height;
 	    }
+	    ctEnsureLimits( ct );
 
 	    ctDraw(co);
 	    if(co->callback) co->callback(co, co->callbackData);
@@ -672,11 +694,13 @@
 	break;
 
     case EV_FOCUS:
+	ct->isActive = 1;
 	ctDraw(co);
 	er.result = ER_SWALLOWED;
 	break;
 	
     case EV_UNFOCUS:
+	ct->isActive = 0;
 	ctDraw(co);
 	er.result = ER_SWALLOWED;
 	break;
diff -Naur newt-0.52.2.orig/checkboxtree.c.orig newt-0.52.2/checkboxtree.c.orig
--- newt-0.52.2.orig/checkboxtree.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ newt-0.52.2/checkboxtree.c.orig	2007-03-26 21:15:01.000000000 +0300
@@ -0,0 +1,821 @@
+#include <slang.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "newt.h"
+#include "newt_pr.h"
+
+struct items {
+    char * text;
+    const void *data;
+    unsigned char selected;
+    struct items *next;
+    struct items *prev;
+    struct items *branch;
+    int flags;
+    int depth;
+};
+
+struct CheckboxTree {
+    newtComponent sb;
+    struct items * itemlist;
+    struct items ** flatList, ** currItem, ** firstItem;
+    int flatCount;
+    int flags;
+    int sbAdjust;
+    int curWidth;
+    int userHasSetWidth;
+    char * seq;
+    char * result;
+};
+
+static void ctDraw(newtComponent c);
+static void ctDestroy(newtComponent co);
+static void ctPlace(newtComponent co, int newLeft, int newTop);
+struct eventResult ctEvent(newtComponent co, struct event ev);
+static void ctMapped(newtComponent co, int isMapped);
+static struct items * findItem(struct items * items, const void * data);
+static void buildFlatList(newtComponent co);
+static void doBuildFlatList(struct CheckboxTree * ct, struct items * item);
+enum countWhat { COUNT_EXPOSED=0, COUNT_SELECTED=1 };
+static int countItems(struct items * item, enum countWhat justExposed);
+static inline void updateWidth(newtComponent co, struct CheckboxTree * ct,
+				int maxField);
+
+static struct componentOps ctOps = {
+    ctDraw,
+    ctEvent,
+    ctDestroy,
+    ctPlace,
+    ctMapped,
+} ;
+
+static inline void updateWidth(newtComponent co, struct CheckboxTree * ct,
+				int maxField) {
+    ct->curWidth = maxField;
+    co->width = ct->curWidth + ct->sbAdjust;
+
+    if (ct->sb)
+	ct->sb->left = co->left + co->width - 1;
+}
+
+static int countItems(struct items * item, enum countWhat what) {
+    int count = 0;
+
+    while (item) {
+        if ((!item->branch && item->selected == what) || (what == COUNT_EXPOSED))
+	    count++;
+	if (item->branch || (what == COUNT_EXPOSED && item->selected))
+	    count += countItems(item->branch, what);
+	item = item->next;
+    }
+
+    return count;
+}
+
+static void doBuildFlatList(struct CheckboxTree * ct, struct items * item) {
+    while (item) {
+    	ct->flatList[ct->flatCount++] = item;
+	if (item->branch && item->selected) doBuildFlatList(ct, item->branch);
+	item = item->next;
+    }
+}
+
+/* FIXME: Check what happens on malloc failure.
+ */
+static void buildFlatList(newtComponent co) {
+    struct CheckboxTree * ct = co->data;
+
+    if (ct->flatList) free(ct->flatList);
+    ct->flatCount = countItems(ct->itemlist, COUNT_EXPOSED);
+
+    ct->flatList = malloc(sizeof(*ct->flatList) * (ct->flatCount+1));
+    ct->flatCount = 0;
+    doBuildFlatList(ct, ct->itemlist);
+    ct->flatList[ct->flatCount] = NULL;
+}
+
+int newtCheckboxTreeAddItem(newtComponent co, 
+			    const char * text, const void * data,
+			    int flags, int index, ...) {
+    va_list argList;
+    int numIndexes;
+    int * indexes;
+    int i;
+
+    va_start(argList, index);
+    numIndexes = 0;
+    i = index;
+    while (i != NEWT_ARG_LAST) {
+	numIndexes++;
+	i = va_arg(argList, int);
+    }
+
+    va_end(argList);
+
+    indexes = alloca(sizeof(*indexes) * (numIndexes + 1));
+    va_start(argList, index);
+    numIndexes = 0;
+    i = index;
+    va_start(argList, index);
+    while (i != NEWT_ARG_LAST) {
+	indexes[numIndexes++] = i;
+	i = va_arg(argList, int);
+    }
+    va_end(argList);
+
+    indexes[numIndexes++] = NEWT_ARG_LAST;
+
+    return newtCheckboxTreeAddArray(co, text, data, flags, indexes);
+}
+
+static int doFindItemPath(struct items * items, void * data, int * path, 
+			  int * len) {
+    int where = 0;
+
+    while (items) {
+	if (items->data == data) {
+	    if (path) path[items->depth] = where;
+	    if (len) *len = items->depth + 1;
+	    return 1;
+	}
+
+	if (items->branch && doFindItemPath(items->branch, data, path, len)) {
+	    if (path) path[items->depth] = where;
+	    return 1;
+	}
+
+	items = items->next;
+	where++;
+    }
+
+    return 0;
+}
+
+int * newtCheckboxTreeFindItem(newtComponent co, void * data) {
+    int len;
+    int * path;
+    struct CheckboxTree * ct = co->data;
+
+    if (!doFindItemPath(ct->itemlist, data, NULL, &len)) return NULL;
+
+    path = malloc(sizeof(*path) * (len + 1));
+    doFindItemPath(ct->itemlist, data, path, NULL);
+    path[len] = NEWT_ARG_LAST;
+
+    return path;
+}
+
+int newtCheckboxTreeAddArray(newtComponent co, 
+			    const char * text, const void * data,
+			    int flags, int * indexes) {
+    struct items * curList, * newNode, * item = NULL;
+    struct items ** listPtr = NULL;
+    int i, index, numIndexes, width;
+    struct CheckboxTree * ct = co->data;
+
+    numIndexes = 0;
+    while (indexes[numIndexes] != NEWT_ARG_LAST) numIndexes++;
+
+    if (!ct->itemlist) {
+	if (numIndexes > 1) return -1;
+
+    	ct->itemlist = malloc(sizeof(*ct->itemlist)); // FIXME: Error check?
+    	item = ct->itemlist;
+	item->prev = NULL;
+	item->next = NULL;
+    } else {
+	curList = ct->itemlist;
+	listPtr = &ct->itemlist;
+
+	i = 0;
+	index = indexes[i];
+	while (i < numIndexes) {
+	    item = curList;
+
+	    if (index == NEWT_ARG_APPEND) {
+	    	item = NULL;
+	    } else {
+		while (index && item) 
+		    item = item->next, index--;
+	    }
+
+	    i++;
+	    if (i < numIndexes) {
+		curList = item->branch;
+		listPtr = &item->branch;
+		if (!curList && (i + 1 != numIndexes)) return -1;
+
+		index = indexes[i];
+	    }
+	}
+
+	if (!curList) { 			/* create a new branch */
+	    item = malloc(sizeof(*curList->prev));
+	    item->next = item->prev = NULL;
+	    *listPtr = item;
+	} else if (!item) {			/* append to end */
+	    item = curList;
+	    while (item->next) item = item->next;
+	    item->next = malloc(sizeof(*curList->prev)); // FIXME Error check
+	    item->next->prev = item;
+	    item = item->next;
+	    item->next = NULL;
+	} else { 
+	    newNode = malloc(sizeof(*newNode)); // FIXME Error check ? 
+	    newNode->prev = item->prev;
+	    newNode->next = item;
+
+	    if (item->prev) item->prev->next = newNode;
+	    item->prev = newNode;
+	    item = newNode;
+	    if (!item->prev) *listPtr = item;
+	}
+    }
+    	
+    item->text = strdup(text);
+    item->data = data;
+    if (flags & NEWT_FLAG_SELECTED) {
+    	item->selected = 1;
+    } else {
+	item->selected = 0;
+    }
+    item->flags = flags;
+    item->branch = NULL;
+    item->depth = numIndexes - 1;
+
+    i = 4 + (3 * item->depth);
+    width = wstrlen(text, -1);
+
+    if ((ct->userHasSetWidth == 0) && ((width + i + ct->sbAdjust) > co->width)) {
+	updateWidth(co, ct, width + i);
+    }
+
+    return 0;
+}
+
+static struct items * findItem(struct items * items, const void * data) {
+    struct items * i;
+
+    while (items) {
+	if (items->data == data) return items;
+    	if (items->branch) {
+	    i = findItem(items->branch, data);
+	    if (i) return i;
+	}
+
+	items = items->next;
+    }
+
+    return NULL;
+}
+
+static void listSelected(struct items * items, int * num, const void ** list, int seqindex) {
+    while (items) {
+	    if ((seqindex ? items->selected==seqindex : items->selected) && !items->branch)
+	    list[(*num)++] = (void *) items->data;
+	if (items->branch)
+	    listSelected(items->branch, num, list, seqindex);
+	items = items->next;
+    }
+}
+
+void newtCheckboxTreeSetWidth(newtComponent co, int width) {
+    struct CheckboxTree * ct = co->data;
+
+    co->width = width;
+    ct->curWidth = co->width - ct->sbAdjust;
+    ct->userHasSetWidth = 1;
+    if (ct->sb) ct->sb->left = co->width + co->left - 1;
+    ctDraw(co);
+}
+
+const void ** newtCheckboxTreeGetSelection(newtComponent co, int *numitems)
+{
+    return newtCheckboxTreeGetMultiSelection(co, numitems, 0);
+}
+
+const void ** newtCheckboxTreeGetMultiSelection(newtComponent co, int *numitems, char seqnum)
+{
+    struct CheckboxTree * ct;
+    const void **retval;
+    int seqindex=0;
+
+    if(!co || !numitems) return NULL;
+
+    ct = co->data;
+	
+    if (seqnum) {
+	    while( ct->seq[seqindex] && ( ct->seq[seqindex] != seqnum )) seqindex++;
+    } else {
+	    seqindex = 0;
+    }
+
+    *numitems = countItems(ct->itemlist, (seqindex ? seqindex : COUNT_SELECTED));
+    if (!*numitems) return NULL;
+    
+    retval = malloc(*numitems * sizeof(void *));
+    *numitems = 0;
+    listSelected(ct->itemlist, numitems, retval, seqindex);
+
+    return retval;
+}
+
+newtComponent newtCheckboxTree(int left, int top, int height, int flags) {
+	return newtCheckboxTreeMulti(left, top, height, NULL, flags);
+}
+
+newtComponent newtCheckboxTreeMulti(int left, int top, int height, char *seq, int flags) {
+    newtComponent co;
+    struct CheckboxTree * ct;
+
+    co = malloc(sizeof(*co));
+    ct = malloc(sizeof(struct CheckboxTree));
+    co->callback = NULL;
+    co->data = ct;
+    co->left = left;
+    co->top = top;
+    co->ops = &ctOps;
+    co->takesFocus = 1;
+    co->height = height;
+    co->width = 0;
+    co->isMapped = 0;
+    ct->curWidth = 0;
+    ct->userHasSetWidth = 0;
+    ct->itemlist = NULL;
+    ct->firstItem = NULL;
+    ct->currItem = NULL;
+    ct->flatList = NULL;
+
+    ct->flags = flags;
+
+    if (seq)
+	ct->seq = strdup(seq);
+    else
+	ct->seq = strdup(" *");
+    if (flags & NEWT_FLAG_SCROLL) {
+	ct->sb = newtVerticalScrollbar(left, top, height,
+				       COLORSET_LISTBOX, COLORSET_ACTLISTBOX);
+	ct->sbAdjust = 2;
+    } else {
+	ct->sb = NULL;
+	ct->sbAdjust = 0;
+    }
+    
+    return co;
+}
+
+static void ctMapped(newtComponent co, int isMapped) {
+    struct CheckboxTree * ct = co->data;
+
+    co->isMapped = isMapped;
+    if (ct->sb)
+	ct->sb->ops->mapped(ct->sb, isMapped);
+}
+
+static void ctPlace(newtComponent co, int newLeft, int newTop) {
+    struct CheckboxTree * ct = co->data;
+
+    co->top = newTop;
+    co->left = newLeft;
+
+    if (ct->sb)
+	ct->sb->ops->place(ct->sb, co->left + co->width - 1, co->top);
+}
+
+int ctSetItem(newtComponent co, struct items *item, enum newtFlagsSense sense)
+{
+    struct CheckboxTree * ct = co->data;
+    struct items * currItem;
+    struct items * firstItem;
+    
+    if (!item)
+	return 1;
+    
+    switch(sense) {
+	case NEWT_FLAGS_RESET:
+	    item->selected = 0;
+	    break;
+	case NEWT_FLAGS_SET:
+	    item->selected = 1;
+	    break;
+	case NEWT_FLAGS_TOGGLE:
+	    if (item->branch)
+	      item->selected = !item->selected;
+	    else if (!(ct->flags & NEWT_CHECKBOXTREE_UNSELECTABLE)) {
+		    item->selected++;
+		    if (item->selected==strlen(ct->seq))
+		      item->selected = 0;
+	    }
+	    break;
+    }
+
+    if (item->branch) {
+    	currItem = *ct->currItem;
+	firstItem = *ct->firstItem;
+
+    	buildFlatList(co);
+
+    	ct->currItem = ct->flatList;
+	while (*ct->currItem != currItem) ct->currItem++;
+
+    	ct->firstItem = ct->flatList;
+    	if (ct->flatCount > co->height) {
+		struct items ** last = ct->flatList + ct->flatCount - co->height;
+		while (*ct->firstItem != firstItem && ct->firstItem != last)
+		    ct->firstItem++;
+	}
+    }
+
+    return 0;
+}
+
+static void ctSetItems(struct items *item, int selected)
+{
+    for (; item; item = item->next) {
+	if (!item->branch)
+	    item->selected = selected;
+	else
+	    ctSetItems(item->branch, selected);
+    }
+}
+
+static void ctDraw(newtComponent co) {
+    struct CheckboxTree * ct = co->data;
+    struct items ** item; 
+    int i, j;
+    char * spaces;
+    int currRow;
+
+    if (!co->isMapped) return ;
+
+    if (!ct->firstItem) {
+	buildFlatList(co);
+	ct->firstItem = ct->currItem = ct->flatList;
+    }
+
+    item = ct->firstItem;
+    
+    i = 0;
+
+    newtTrashScreen();
+    
+    while (*item && i < co->height) {
+	newtGotorc(co->top + i, co->left);
+	if (*item == *ct->currItem) {
+	    SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
+	    currRow = co->top + i;
+	} else
+	    SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+
+	for (j = 0; j < (*item)->depth; j++)
+	    SLsmg_write_string("   ");
+
+	if ((*item)->branch) {
+	    if ((*item)->selected) 
+		SLsmg_write_string("<-> ");
+	    else
+		SLsmg_write_string("<+> ");
+	} else {
+	    if (ct->flags & NEWT_CHECKBOXTREE_HIDE_BOX) {
+		if ((*item)->selected)
+		    SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
+	        SLsmg_write_string("    ");
+	    } else {
+	        char tmp[5];
+	        snprintf(tmp,5,"[%c] ",ct->seq[(*item)->selected]);
+	        SLsmg_write_string(tmp);
+	    }
+	}
+
+	j = 4 + (3 * (*item)->depth);
+	SLsmg_write_nstring(NULL, co->width - j);
+	newtGotorc(co->top + i, co->left + j);
+	if (wstrlen((*item)->text, -1) > co->width - j) {
+	    char *tmp;
+	    tmp = strdup((*item)->text);
+	    trim_string(tmp, co->width - j);
+	    SLsmg_write_string(tmp);
+	    free(tmp);
+	} else
+	    SLsmg_write_string((*item)->text);
+
+	SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+
+	item++;
+	i++;
+    }
+
+    /* There could be empty lines left (i.e. if the user closes an expanded
+       list which is the last thing in the tree, and whose elements are
+       displayed at the bottom of the screen */
+    if (i < co->height) {
+	spaces = alloca(co->width);
+	memset(spaces, ' ', co->width);
+	SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+    }
+    while (i < co->height) {
+	newtGotorc(co->top + i, co->left);
+	SLsmg_write_nstring(spaces, co->width);
+	i++;
+    }
+    
+    if(ct->sb) {
+	newtScrollbarSet(ct->sb, ct->currItem - ct->flatList, 
+			 ct->flatCount - 1);
+	ct->sb->ops->draw(ct->sb);
+    }
+
+    newtGotorc(currRow, co->left + 1);
+}
+
+static void ctDestroy(newtComponent co) {
+    struct CheckboxTree * ct = co->data;
+    struct items * item, * nextitem;
+
+    nextitem = item = ct->itemlist;
+
+    while (item != NULL) {
+	nextitem = item->next;
+	free(item->text);
+	free(item);
+	item = nextitem;
+    }
+
+    free(ct->seq);
+    free(ct);
+    free(co);
+}
+
+static void ctEnsureLimits( struct CheckboxTree *ct ) {
+    struct items **listEnd = ct->flatList + ct->flatCount - 1;
+    if (ct->firstItem < ct->flatList)
+        ct->firstItem = ct->flatList;
+    if (ct->currItem < ct->flatList)
+        ct->currItem = ct->flatList;
+    if (ct->firstItem > listEnd) {
+        ct->firstItem = listEnd;
+        ct->currItem = listEnd;
+    }
+}
+
+struct eventResult ctEvent(newtComponent co, struct event ev) {
+    struct CheckboxTree * ct = co->data;
+    struct eventResult er;
+    struct items ** listEnd, ** lastItem;
+    int key, selnum = 1;
+
+    er.result = ER_IGNORED;
+
+    if(ev.when == EV_EARLY || ev.when == EV_LATE) {
+	return er;
+    }
+
+    switch(ev.event) {
+    case EV_KEYPRESS:
+	key = ev.u.key;
+	if (key == (char) key && key != ' ') {
+	    for (selnum = 0; ct->seq[selnum]; selnum++)
+	    if (key == ct->seq[selnum])
+		break;
+	    if (!ct->seq[selnum])
+		switch (key) {
+		case '-': selnum = 0; break;
+		case '+':
+		case '*': selnum = 1; break;
+		}
+	    if (ct->seq[selnum])
+		key = '*';
+	}
+	switch(key) {
+	case ' ':
+	case NEWT_KEY_ENTER:
+	    ctSetItem(co, *ct->currItem, NEWT_FLAGS_TOGGLE);
+	    er.result = ER_SWALLOWED;
+	    if (!(*ct->currItem)->branch || (*ct->currItem)->selected)
+		key = NEWT_KEY_DOWN;
+	    else
+		key = '*';
+	    break;
+	case '*':
+	    if ((*ct->currItem)->branch) {
+		ctSetItems((*ct->currItem)->branch, selnum);
+		if (!(*ct->currItem)->selected)
+		    key = NEWT_KEY_DOWN;
+	    } else {
+		(*ct->currItem)->selected = selnum;
+		key = NEWT_KEY_DOWN;
+	    }
+	    er.result = ER_SWALLOWED;
+	    break;
+	}
+	switch (key) {
+	case '*':
+	    ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    return er;
+	case NEWT_KEY_HOME:
+	    ct->currItem = ct->flatList;
+	    ct->firstItem = ct->flatList;
+	    ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    return er;
+	case NEWT_KEY_END:
+	    ct->currItem = ct->flatList + ct->flatCount - 1;
+	    if (ct->flatCount <= co->height)
+		ct->firstItem = ct->flatList;
+	    else
+		ct->firstItem = ct->flatList + ct->flatCount - co->height;
+	    ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    return er;
+	case NEWT_KEY_DOWN:
+	    if (ev.u.key != NEWT_KEY_DOWN) {
+		if(co->callback) co->callback(co, co->callbackData);
+		if (strlen(ct->seq) != 2) {
+		    ctDraw(co);
+		    return er;
+		}
+	    }
+	    if ((ct->currItem - ct->flatList + 1) < ct->flatCount) {
+		ct->currItem++;
+
+		if (ct->currItem - ct->firstItem >= co->height) 
+		    ct->firstItem++;
+
+		ctDraw(co);
+	    } else if (ev.u.key != NEWT_KEY_DOWN)
+	        ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    return er;
+	case NEWT_KEY_UP:
+	    if (ct->currItem != ct->flatList) {
+		ct->currItem--;
+
+		if (ct->currItem < ct->firstItem)
+		    ct->firstItem = ct->currItem;
+		    
+		ctDraw(co);
+	    }
+	    er.result = ER_SWALLOWED;
+	    if(co->callback) co->callback(co, co->callbackData);
+	    return er;
+	case NEWT_KEY_PGUP:
+	    if (ct->firstItem - co->height < ct->flatList) {
+	    	ct->firstItem = ct->currItem = ct->flatList;
+	    } else {
+		ct->currItem -= co->height;
+		ct->firstItem -= co->height;
+	    }
+	    ctEnsureLimits( ct );
+
+	    ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    return er;
+	case NEWT_KEY_PGDN:
+	    listEnd = ct->flatList + ct->flatCount - 1;
+	    lastItem = ct->firstItem + co->height - 1;
+
+	    if (lastItem + co->height > listEnd) {
+	    	ct->firstItem = listEnd - co->height + 1;
+		ct->currItem = listEnd;
+	    } else {
+	    	ct->currItem += co->height;
+		ct->firstItem += co->height;
+	    }
+	    ctEnsureLimits( ct );
+
+	    ctDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    return er;
+	}
+	break;
+
+    case EV_FOCUS:
+	ctDraw(co);
+	er.result = ER_SWALLOWED;
+	break;
+	
+    case EV_UNFOCUS:
+	ctDraw(co);
+	er.result = ER_SWALLOWED;
+	break;
+    default:
+	break;
+    }
+
+    return er;
+}
+
+const void * newtCheckboxTreeGetCurrent(newtComponent co) {
+    struct CheckboxTree * ct = co->data;
+
+    if (!ct->currItem) return NULL;
+    return (*ct->currItem)->data;
+}
+
+void newtCheckboxTreeSetEntry(newtComponent co, const void * data, const char * text)
+{
+    struct CheckboxTree * ct;
+    struct items * item;
+    int i, width;
+
+    if (!co) return;
+    ct = co->data;
+    item = findItem(ct->itemlist, data);
+    if (!item) return;
+
+    free(item->text);
+    item->text = strdup(text);
+
+    i = 4 + (3 * item->depth);
+
+    width = wstrlen(text, -1);
+    if ((ct->userHasSetWidth == 0) && ((width + i + ct->sbAdjust) > co->width)) {
+	updateWidth(co, ct, width + i);
+    }
+
+    ctDraw(co);
+}
+
+char newtCheckboxTreeGetEntryValue(newtComponent co, const void * data)
+{
+    struct CheckboxTree * ct;
+    struct items * item;
+
+    if (!co) return -1;
+    ct = co->data;
+    item = findItem(ct->itemlist, data);
+    if (!item) return -1;
+    if (item->branch)
+	return item->selected ? NEWT_CHECKBOXTREE_EXPANDED : NEWT_CHECKBOXTREE_COLLAPSED;
+    else
+	return ct->seq[item->selected];
+}
+
+void newtCheckboxTreeSetEntryValue(newtComponent co, const void * data, char value)
+{
+    struct CheckboxTree * ct;
+    struct items * item;
+    int i;
+
+    if (!co) return;
+    ct = co->data;
+    item = findItem(ct->itemlist, data);
+    if (!item || item->branch) return;
+
+    for(i = 0; ct->seq[i]; i++)
+	if (value == ct->seq[i])
+	    break;
+
+    if (!ct->seq[i]) return;
+    item->selected = i;
+
+    ctDraw(co);
+}
+
+
+void newtCheckboxTreeSetCurrent(newtComponent co, void * data) {
+    struct CheckboxTree * ct = co->data;
+    int * path;
+    int i, j;
+    struct items * treeTop, * item;
+
+    path = newtCheckboxTreeFindItem(co, data);
+    if (!path) return;
+
+    /* traverse the path and turn on all of the branches to this point */
+    for (i = 0, treeTop = ct->itemlist; path[i + 1] != NEWT_ARG_LAST; i++) {
+	for (j = 0, item = treeTop; j < path[i]; j++)
+	    item = item->next;
+
+	item->selected = 1;
+	treeTop = item->branch;
+    }
+
+    buildFlatList(co);
+	
+    item = findItem(ct->itemlist, data);
+
+    i = 0;
+    while (ct->flatList[i] != item) i++;
+
+    /* choose the top item */
+    j = i - (co->height / 2);
+
+    if ((j + co->height) > ct->flatCount) 
+	j = ct->flatCount - co->height;
+    
+    if (j < 0)
+	j = 0;
+
+    ct->firstItem = ct->flatList + j;
+    ct->currItem = ct->flatList + i;
+
+    ctDraw(co);
+}
diff -Naur newt-0.52.2.orig/checkboxtree.c.rej newt-0.52.2/checkboxtree.c.rej
--- newt-0.52.2.orig/checkboxtree.c.rej	1970-01-01 02:00:00.000000000 +0200
+++ newt-0.52.2/checkboxtree.c.rej	2007-03-26 21:16:24.000000000 +0300
@@ -0,0 +1,30 @@
+***************
+*** 487,498 ****
+  	        SLsmg_write_string(tmp);
+  	    }
+  	}
+  
+  	SLsmg_write_nstring((*item)->text, co->width - 4 - 
+  					   (3 * (*item)->depth));
+  
+- 	SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+- 
+  	item++;
+  	i++;
+      }
+--- 484,498 ----
+  	        SLsmg_write_string(tmp);
+  	    }
+  	}
++ 	if (*item == *ct->currItem) {
++ 	    SLsmg_set_color(ct->isActive ?
++ 		    NEWT_COLORSET_ACTSELLISTBOX : NEWT_COLORSET_ACTLISTBOX);
++ 	    currRow = co->top + i;
++ 	}
+  
+  	SLsmg_write_nstring((*item)->text, co->width - 4 - 
+  					   (3 * (*item)->depth));
+  
+  	item++;
+  	i++;
+      }
diff -Naur newt-0.52.2.orig/entry.c newt-0.52.2/entry.c
--- newt-0.52.2.orig/entry.c	2005-09-30 17:05:55.000000000 +0300
+++ newt-0.52.2/entry.c	2007-03-26 21:14:35.000000000 +0300
@@ -322,6 +322,7 @@
     switch (key) {
       case '\r':				/* Return */
 	if (en->flags & NEWT_FLAG_RETURNEXIT) {
+	    newtCursorOff();
 	    er.result = ER_EXITFORM;
 	} else {
 	    er.result = ER_NEXTCOMP;
diff -Naur newt-0.52.2.orig/form.c newt-0.52.2/form.c
--- newt-0.52.2.orig/form.c	2005-09-21 12:32:01.000000000 +0300
+++ newt-0.52.2/form.c	2007-03-26 21:16:24.000000000 +0300
@@ -1027,8 +1027,17 @@
 		    }
 		}
 
-		if (key == NEWT_KEY_F1 && form->helpTag && form->helpCb)
+		if (key == NEWT_KEY_F1 && form->helpTag && form->helpCb) {
+		    if (form->currComp != -1) {
+			ev.event = EV_UNFOCUS;
+			sendEvent(form->elements[form->currComp].co, ev);
+		    }
 		    form->helpCb(co, form->helpTag);
+		    if (form->currComp != -1) {
+			ev.event = EV_FOCUS;
+			sendEvent(form->elements[form->currComp].co, ev);
+		    }
+		}
 
 		if (!done) {
 		    ev.event = EV_KEYPRESS;
diff -Naur newt-0.52.2.orig/listbox.c newt-0.52.2/listbox.c
--- newt-0.52.2.orig/listbox.c	2005-09-30 17:05:55.000000000 +0300
+++ newt-0.52.2/listbox.c	2007-03-26 21:16:24.000000000 +0300
@@ -518,7 +518,7 @@
 
 	newtGotorc(co->top + i + li->bdyAdjust, co->left + li->bdxAdjust);
 	if(j + i == li->currItem) {
-	    if(item->isSelected)
+	    if(li->isActive)
 		SLsmg_set_color(NEWT_COLORSET_ACTSELLISTBOX);
 	    else
 		SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
@@ -527,8 +527,23 @@
 	else
 	    SLsmg_set_color(NEWT_COLORSET_LISTBOX);
 
-	SLsmg_write_nstring(item->text, li->curWidth);
-
+	SLsmg_write_nstring(NULL, li->curWidth);
+	newtGotorc(co->top + i + li->bdyAdjust, co->left + li->bdxAdjust);
+	if (wstrlen(item->text, -1) > li->curWidth) {
+	    char *tmp;
+	    tmp = strdup(item->text);
+	    trim_string(tmp, li->curWidth);
+	    SLsmg_write_string(tmp);
+	    free(tmp);
+	} else
+	    SLsmg_write_string(item->text);
+
+	if (li->flags & NEWT_FLAG_MULTIPLE) {
+	    newtGotorc(co->top + i + li->bdyAdjust, co->left + li->bdxAdjust);
+	    SLsmg_set_color(item->isSelected ?
+		    NEWT_COLORSET_SELLISTBOX : NEWT_COLORSET_LISTBOX);
+	    SLsmg_write_nstring(item->text, 1);
+	}
     }
     newtGotorc(co->top + (li->currItem - li->startShowItem) + li->bdyAdjust,
                co->left + li->bdxAdjust);
diff -Naur newt-0.52.2.orig/listbox.c.orig newt-0.52.2/listbox.c.orig
--- newt-0.52.2.orig/listbox.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ newt-0.52.2/listbox.c.orig	2007-03-26 21:14:43.000000000 +0300
@@ -0,0 +1,774 @@
+/* This goofed-up box whacked into shape by Elliot Lee <sopwith@cuc.edu>
+   (from the original listbox by Erik Troan <ewt@redhat.com>)
+   and contributed to newt for use under the LGPL license.
+   Copyright (C) 1996, 1997 Elliot Lee */
+
+#include <slang.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "newt.h"
+#include "newt_pr.h"
+
+
+/* Linked list of items in the listbox */
+struct items {
+    char * text;
+    const void *data;
+    unsigned char isSelected;
+    struct items *next;
+};
+
+/* Holds all the relevant information for this listbox */
+struct listbox {
+    newtComponent sb;   /* Scrollbar on right side of listbox */
+    int curWidth;	/* size of text w/o scrollbar or border*/
+    int curHeight;	/* size of text w/o border */
+    int sbAdjust;
+    int bdxAdjust, bdyAdjust;
+    int numItems, numSelected;
+    int userHasSetWidth;
+    int currItem, startShowItem; /* startShowItem is the first item displayed
+				   on the screen */
+    int isActive; /* If we handle key events all the time, it seems
+		     to do things even when they are supposed to be for
+		     another button/whatever */
+    struct items *boxItems;
+    int grow;
+    int flags; /* flags for this listbox, right now just
+		  NEWT_FLAG_RETURNEXIT */
+};
+
+static void listboxDraw(newtComponent co);
+static void listboxDestroy(newtComponent co);
+static struct eventResult listboxEvent(newtComponent co, struct event ev);
+static void newtListboxRealSetCurrent(newtComponent co);
+static void listboxPlace(newtComponent co, int newLeft, int newTop);
+static inline void updateWidth(newtComponent co, struct listbox * li,
+				int maxField);
+static void listboxMapped(newtComponent co, int isMapped);
+
+static struct componentOps listboxOps = {
+    listboxDraw,
+    listboxEvent,
+    listboxDestroy,
+    listboxPlace,
+    listboxMapped,
+};
+
+static void listboxMapped(newtComponent co, int isMapped) {
+    struct listbox * li = co->data;
+
+    co->isMapped = isMapped;
+    if (li->sb)
+	li->sb->ops->mapped(li->sb, isMapped);
+}
+
+static void listboxPlace(newtComponent co, int newLeft, int newTop) {
+    struct listbox * li = co->data;
+
+    co->top = newTop;
+    co->left = newLeft;
+
+    if (li->sb)
+	li->sb->ops->place(li->sb, co->left + co->width - li->bdxAdjust - 1,
+			   co->top);
+}
+
+newtComponent newtListbox(int left, int top, int height, int flags) {
+    newtComponent co, sb;
+    struct listbox * li;
+
+    if (!(co = malloc(sizeof(*co))))
+	return NULL;
+
+    if (!(li = malloc(sizeof(struct listbox)))) {
+	free(co);
+	return NULL;
+    }
+
+    li->boxItems = NULL;
+    li->numItems = 0;
+    li->currItem = 0;
+    li->numSelected = 0;
+    li->isActive = 0;
+    li->userHasSetWidth = 0;
+    li->startShowItem = 0;
+    li->sbAdjust = 0;
+    li->bdxAdjust = 0;
+    li->bdyAdjust = 0;
+    li->flags = flags & (NEWT_FLAG_RETURNEXIT | NEWT_FLAG_BORDER |
+			 NEWT_FLAG_MULTIPLE | NEWT_FLAG_SHOWCURSOR);
+
+    if (li->flags & NEWT_FLAG_BORDER) {
+	li->bdxAdjust = 2;
+	li->bdyAdjust = 1;
+    }
+
+    co->height = height;
+    li->curHeight = co->height - (2 * li->bdyAdjust);
+
+    if (height) {
+	li->grow = 0;
+	if (flags & NEWT_FLAG_SCROLL) {
+	    sb = newtVerticalScrollbar(left, top + li->bdyAdjust,
+					li->curHeight,
+					COLORSET_LISTBOX, COLORSET_ACTLISTBOX);
+	    li->sbAdjust = 3;
+	} else {
+	    sb = NULL;
+	}
+    } else {
+	li->grow = 1;
+	sb = NULL;
+    }
+
+    li->sb = sb;
+    co->data = li;
+    co->isMapped = 0;
+    co->left = left;
+    co->top = top;
+    co->ops = &listboxOps;
+    co->takesFocus = 1;
+    co->callback = NULL;
+
+    updateWidth(co, li, 5);
+
+    return co;
+}
+
+static inline void updateWidth(newtComponent co, struct listbox * li,
+				int maxField) {
+    li->curWidth = maxField;
+    co->width = li->curWidth + li->sbAdjust + 2 * li->bdxAdjust;
+
+    if (li->sb)
+	li->sb->left = co->left + co->width - li->bdxAdjust - 1;
+}
+
+void newtListboxSetCurrentByKey(newtComponent co, void * key) {
+    struct listbox * li = co->data;
+    struct items * item;
+    int i;
+
+    item = li->boxItems, i = 0;
+    while (item && item->data != key)
+	item = item->next, i++;
+
+    if (item)
+	newtListboxSetCurrent(co, i);
+}
+
+void newtListboxSetCurrent(newtComponent co, int num)
+{
+    struct listbox * li = co->data;
+
+    if (num >= li->numItems)
+	li->currItem = li->numItems - 1;
+    else if (num < 0)
+	li->currItem = 0;
+    else
+	li->currItem = num;
+
+    if (li->currItem < li->startShowItem)
+	li->startShowItem = li->currItem;
+    else if (li->currItem - li->startShowItem > li->curHeight - 1)
+	li->startShowItem = li->currItem - li->curHeight + 1;
+    if (li->startShowItem + li->curHeight > li->numItems)
+	li->startShowItem = li->numItems - li->curHeight;
+    if(li->startShowItem < 0)
+	li->startShowItem = 0;
+
+    newtListboxRealSetCurrent(co);
+}
+
+static void newtListboxRealSetCurrent(newtComponent co)
+{
+    struct listbox * li = co->data;
+
+    if(li->sb)
+	newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+    listboxDraw(co);
+    if(co->callback) co->callback(co, co->callbackData);
+}
+
+void newtListboxSetWidth(newtComponent co, int width) {
+    struct listbox * li = co->data;
+
+    co->width = width;
+    li->curWidth = co->width - li->sbAdjust - 2 * li->bdxAdjust;
+    li->userHasSetWidth = 1;
+    if (li->sb) li->sb->left = co->width + co->left - 1;
+    listboxDraw(co);
+}
+
+void * newtListboxGetCurrent(newtComponent co) {
+    struct listbox * li = co->data;
+    int i;
+    struct items *item;
+
+    for(i = 0, item = li->boxItems; item != NULL && i < li->currItem;
+	i++, item = item->next);
+
+    if (item)
+	return (void *)item->data;
+    else
+	return NULL;
+}
+
+void newtListboxSelectItem(newtComponent co, const void * key,
+	enum newtFlagsSense sense)
+{
+    struct listbox * li = co->data;
+    int i;
+    struct items * item;
+
+    item = li->boxItems, i = 0;
+    while (item && item->data != key)
+	item = item->next, i++;
+
+    if (!item) return;
+
+    if (item->isSelected)
+	li->numSelected--;
+
+    switch(sense) {
+	case NEWT_FLAGS_RESET:
+		item->isSelected = 0; break;
+	case NEWT_FLAGS_SET:
+		item->isSelected = 1; break;
+	case NEWT_FLAGS_TOGGLE:
+		item->isSelected = !item->isSelected;
+    }
+
+    if (item->isSelected)
+	li->numSelected++;
+
+    listboxDraw(co);
+}
+
+void newtListboxClearSelection(newtComponent co)
+{
+    struct items *item;
+    struct listbox * li = co->data;
+
+    for(item = li->boxItems; item != NULL;
+	item = item->next)
+	item->isSelected = 0;
+    li->numSelected = 0;
+    listboxDraw(co);
+}
+
+/* Free the returned array after use, but NOT the values in the array */
+void ** newtListboxGetSelection(newtComponent co, int *numitems)
+{
+    struct listbox * li;
+    int i;
+    void **retval;
+    struct items *item;
+
+    if(!co || !numitems) return NULL;
+
+    li = co->data;
+    if(!li || !li->numSelected) return NULL;
+
+    retval = malloc(li->numSelected * sizeof(void *));
+    for(i = 0, item = li->boxItems; item != NULL;
+	item = item->next)
+	if(item->isSelected)
+	    retval[i++] = (void *)item->data;
+    *numitems = li->numSelected;
+    return retval;
+}
+
+void newtListboxSetEntry(newtComponent co, int num, const char * text) {
+    struct listbox * li = co->data;
+    int i;
+    struct items *item;
+
+    for(i = 0, item = li->boxItems; item != NULL && i < num;
+	i++, item = item->next);
+
+    if(!item)
+	return;
+    else {
+	free(item->text);
+	item->text = strdup(text);
+    }
+    if (li->userHasSetWidth == 0 && wstrlen(text,-1) > li->curWidth) {
+	updateWidth(co, li, wstrlen(text,-1));
+    }
+
+    if (num >= li->startShowItem && num <= li->startShowItem + co->height)
+	listboxDraw(co);
+}
+
+void newtListboxSetData(newtComponent co, int num, void * data) {
+    struct listbox * li = co->data;
+    int i;
+    struct items *item;
+
+    for(i = 0, item = li->boxItems; item != NULL && i < num;
+	i++, item = item->next);
+
+    item->data = data;
+}
+
+int newtListboxAppendEntry(newtComponent co, const char * text,
+	                const void * data) {
+    struct listbox * li = co->data;
+    struct items *item;
+
+    if(li->boxItems) {
+	for (item = li->boxItems; item->next != NULL; item = item->next);
+
+	item = item->next = malloc(sizeof(struct items));
+    } else {
+	item = li->boxItems = malloc(sizeof(struct items));
+    }
+
+    if (!li->userHasSetWidth && text && (wstrlen(text,-1) > li->curWidth))
+	updateWidth(co, li, wstrlen(text,-1));
+
+    item->text = strdup(text); item->data = data; item->next = NULL;
+    item->isSelected = 0;
+
+    if (li->grow)
+	co->height++, li->curHeight++;
+    li->numItems++;
+
+    return 0;
+}
+
+int newtListboxInsertEntry(newtComponent co, const char * text,
+	                   const void * data, void * key) {
+    struct listbox * li = co->data;
+    struct items *item, *t;
+
+    if (li->boxItems) {
+	if (key) {
+	    item = li->boxItems;
+	    while (item && item->data != key) item = item->next;
+
+	    if (!item) return 1;
+
+	    t = item->next;
+	    item = item->next = malloc(sizeof(struct items));
+	    item->next = t;
+	} else {
+	    t = li->boxItems;
+	    item = li->boxItems = malloc(sizeof(struct items));
+	    item->next = t;
+	}
+    } else if (key) {
+	return 1;
+    } else {
+	item = li->boxItems = malloc(sizeof(struct items));
+	item->next = NULL;
+    }
+
+    if (!li->userHasSetWidth && text && (wstrlen(text,-1) > li->curWidth))
+	updateWidth(co, li, wstrlen(text,-1));
+
+    item->text = strdup(text?text:"(null)"); item->data = data;
+    item->isSelected = 0;
+
+    if (li->sb)
+	li->sb->left = co->left + co->width - li->bdxAdjust - 1;
+    li->numItems++;
+
+    listboxDraw(co);
+
+    return 0;
+}
+
+int newtListboxDeleteEntry(newtComponent co, void * key) {
+    struct listbox * li = co->data;
+    int widest = 0, t;
+    struct items *item, *item2 = NULL;
+    int num;
+
+    if (li->boxItems == NULL || li->numItems <= 0)
+	return 0;
+
+    num = 0;
+
+    item2 = NULL, item = li->boxItems;
+    while (item && item->data != key) {
+	item2 = item;
+	item = item->next;
+	num++;
+    }
+
+    if (!item)
+	return -1;
+
+    if (item2)
+	item2->next = item->next;
+    else
+	li->boxItems = item->next;
+
+    free(item->text);
+    free(item);
+    li->numItems--;
+
+    if (!li->userHasSetWidth) {
+	widest = 0;
+	for (item = li->boxItems; item != NULL; item = item->next)
+	    if ((t = wstrlen(item->text,-1)) > widest) widest = t;
+    }
+
+    if (li->currItem >= num)
+	li->currItem--;
+
+    if (!li->userHasSetWidth) {
+	updateWidth(co, li, widest);
+    }
+
+    listboxDraw(co);
+
+    return 0;
+}
+
+void newtListboxClear(newtComponent co)
+{
+    struct listbox * li;
+    struct items *anitem, *nextitem;
+    if(co == NULL || (li = co->data) == NULL)
+	return;
+    for(anitem = li->boxItems; anitem != NULL; anitem = nextitem) {
+	nextitem = anitem->next;
+	free(anitem->text);
+	free(anitem);
+    }
+    li->numItems = li->numSelected = li->currItem = li->startShowItem = 0;
+    li->boxItems = NULL;
+    if (!li->userHasSetWidth)
+	updateWidth(co, li, 5);
+}
+
+int newtListboxItemCount(newtComponent co)
+{
+    struct listbox *li = co->data;
+    return li->numItems;
+}
+
+/* If you don't want to get back the text, pass in NULL for the ptr-ptr. Same
+   goes for the data. */
+void newtListboxGetEntry(newtComponent co, int num, char **text, void **data) {
+    struct listbox * li = co->data;
+    int i;
+    struct items *item;
+
+    if (!li->boxItems || num >= li->numItems) {
+	if(text)
+	    *text = NULL;
+	if(data)
+	    *data = NULL;
+	return;
+    }
+
+    i = 0;
+    item = li->boxItems;
+    while (item && i < num) {
+	i++, item = item->next;
+    }
+
+    if (item) {
+	if (text)
+	    *text = item->text;
+	if (data)
+	    *data = (void *)item->data;
+    }
+}
+
+static void listboxDraw(newtComponent co)
+{
+    struct listbox * li = co->data;
+    struct items *item;
+    int i, j;
+
+    if (!co->isMapped) return ;
+
+    newtTrashScreen();
+    
+    if(li->flags & NEWT_FLAG_BORDER) {
+      if(li->isActive)
+	  SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
+      else
+          SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+
+      newtDrawBox(co->left, co->top, co->width, co->height, 0);
+    }
+
+    if(li->sb)
+	li->sb->ops->draw(li->sb);
+
+    SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+
+    for(i = 0, item = li->boxItems; item != NULL && i < li->startShowItem;
+	i++, item = item->next);
+
+    j = i;
+
+    for (i = 0; item != NULL && i < li->curHeight; i++, item = item->next) {
+	if (!item->text) continue;
+
+	newtGotorc(co->top + i + li->bdyAdjust, co->left + li->bdxAdjust);
+	if(j + i == li->currItem) {
+	    if(item->isSelected)
+		SLsmg_set_color(NEWT_COLORSET_ACTSELLISTBOX);
+	    else
+		SLsmg_set_color(NEWT_COLORSET_ACTLISTBOX);
+	} else if(item->isSelected)
+	    SLsmg_set_color(NEWT_COLORSET_SELLISTBOX);
+	else
+	    SLsmg_set_color(NEWT_COLORSET_LISTBOX);
+
+	SLsmg_write_nstring(NULL, li->curWidth);
+	newtGotorc(co->top + i + li->bdyAdjust, co->left + li->bdxAdjust);
+	if (wstrlen(item->text, -1) > li->curWidth) {
+	    char *tmp;
+	    tmp = strdup(item->text);
+	    trim_string(tmp, li->curWidth);
+	    SLsmg_write_string(tmp);
+	    free(tmp);
+	} else
+	    SLsmg_write_string(item->text);
+
+    }
+    newtGotorc(co->top + (li->currItem - li->startShowItem) + li->bdyAdjust,
+               co->left + li->bdxAdjust);
+}
+
+static struct eventResult listboxEvent(newtComponent co, struct event ev) {
+    struct eventResult er;
+    struct listbox * li = co->data;
+    struct items *item;
+    int i;
+    
+    er.result = ER_IGNORED;
+
+    if(ev.when == EV_EARLY || ev.when == EV_LATE) {
+	return er;
+    }
+
+    switch(ev.event) {
+      case EV_KEYPRESS:
+	if (!li->isActive) break;
+
+	switch(ev.u.key) {
+	  case ' ':
+	    if(!(li->flags & NEWT_FLAG_MULTIPLE)) break;
+	    newtListboxSelectItem(co, newtListboxGetCurrent(co),
+				  NEWT_FLAGS_TOGGLE);
+	    er.result = ER_SWALLOWED;
+	    /* We don't break here, because it is cool to be able to
+	       hold space to select a bunch of items in a list at once */
+
+	  case NEWT_KEY_DOWN:
+	    if(li->numItems <= 0) break;
+	    if(li->currItem < li->numItems - 1) {
+		li->currItem++;
+		if(li->currItem > (li->startShowItem + li->curHeight - 1)) {
+		    li->startShowItem = li->currItem - li->curHeight + 1;
+		    if(li->startShowItem + li->curHeight > li->numItems)
+			li->startShowItem = li->numItems - li->curHeight;
+		}
+		if(li->sb)
+		    newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+		listboxDraw(co);
+	    }
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    break;
+
+	  case NEWT_KEY_ENTER:
+	    if(li->numItems <= 0) break;
+	    if(li->flags & NEWT_FLAG_RETURNEXIT)
+		er.result = ER_EXITFORM;
+	    break;
+
+	  case NEWT_KEY_UP:
+	    if(li->numItems <= 0) break;
+	    if(li->currItem > 0) {
+		li->currItem--;
+		if(li->currItem < li->startShowItem)
+		    li->startShowItem = li->currItem;
+		if(li->sb)
+		    newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+		listboxDraw(co);
+	    }
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    break;
+
+	  case NEWT_KEY_PGUP:
+	    if(li->numItems <= 0) break;
+	    li->startShowItem -= li->curHeight - 1;
+	    if(li->startShowItem < 0)
+		li->startShowItem = 0;
+	    li->currItem -= li->curHeight - 1;
+	    if(li->currItem < 0)
+		li->currItem = 0;
+	    newtListboxRealSetCurrent(co);
+	    er.result = ER_SWALLOWED;
+	    break;
+
+	  case NEWT_KEY_PGDN:
+	    if(li->numItems <= 0) break;
+	    li->startShowItem += li->curHeight;
+	    if(li->startShowItem > (li->numItems - li->curHeight)) {
+		li->startShowItem = li->numItems - li->curHeight;
+	    }
+	    li->currItem += li->curHeight;
+	    if(li->currItem >= li->numItems) {
+		li->currItem = li->numItems - 1;
+	    }
+	    newtListboxRealSetCurrent(co);
+	    er.result = ER_SWALLOWED;
+	    break;
+
+	  case NEWT_KEY_HOME:
+	    if(li->numItems <= 0) break;
+	    newtListboxSetCurrent(co, 0);
+	    er.result = ER_SWALLOWED;
+	    break;
+
+	  case NEWT_KEY_END:
+	    if(li->numItems <= 0) break;
+	    li->startShowItem = li->numItems - li->curHeight;
+	    if(li->startShowItem < 0)
+		li->startShowItem = 0;
+	    li->currItem = li->numItems - 1;
+	    newtListboxRealSetCurrent(co);
+	    er.result = ER_SWALLOWED;
+	    break;
+	  default:
+	      if (li->numItems <= 0) break;
+              if (ev.u.key < NEWT_KEY_EXTRA_BASE && isalpha(ev.u.key)) {
+		  for(i = 0, item = li->boxItems; item != NULL &&
+			  i < li->currItem; i++, item = item->next);
+
+		  if (item && item->text && (toupper(*item->text) == toupper(ev.u.key))) {
+		      item = item->next;
+		      i++;
+		  } else { 
+		      item = li->boxItems;
+		      i = 0;
+		  }
+		  while (item && item->text &&
+			 toupper(*item->text) != toupper(ev.u.key)) {
+		      item = item->next;
+		      i++;
+		  }
+		  if (item) {
+		      li->currItem = i;
+		      if(li->currItem < li->startShowItem ||
+			 li->currItem > li->startShowItem)
+			  li->startShowItem =
+			      li->currItem > li->numItems - li->curHeight ?
+			      li->startShowItem = li->numItems - li->curHeight :
+			      li->currItem;
+		      if(li->sb)
+			  newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+		      newtListboxRealSetCurrent(co);
+		      er.result = ER_SWALLOWED;
+		  }
+	      }
+	}
+	break;
+
+      case EV_FOCUS:
+	li->isActive = 1;
+	listboxDraw(co);
+	if(li->flags & NEWT_FLAG_SHOWCURSOR)
+	  newtCursorOn();
+	er.result = ER_SWALLOWED;
+	break;
+
+      case EV_UNFOCUS:
+	li->isActive = 0;
+	listboxDraw(co);
+	if(li->flags & NEWT_FLAG_SHOWCURSOR)
+	  newtCursorOff();
+	er.result = ER_SWALLOWED;
+	break;
+
+      case EV_MOUSE:
+	  /* if this mouse click was within the listbox, make the current
+	     item the item clicked on. */
+	/* Up scroll arrow */
+	if (li->sb &&
+	    ev.u.mouse.x == co->left + co->width - li->bdxAdjust - 1 &&
+	    ev.u.mouse.y == co->top + li->bdyAdjust) {
+	    if(li->numItems <= 0) break;
+	    if(li->currItem > 0) {
+		li->currItem--;
+		if(li->currItem < li->startShowItem)
+		    li->startShowItem = li->currItem;
+		if(li->sb)
+		    newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+		listboxDraw(co);
+	    }
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    break;
+	}
+	/* Down scroll arrow */
+	if (li->sb &&
+	    ev.u.mouse.x == co->left + co->width - li->bdxAdjust - 1 &&
+	    ev.u.mouse.y == co->top + co->height - li->bdyAdjust - 1) {
+	    if(li->numItems <= 0) break;
+	    if(li->currItem < li->numItems - 1) {
+		li->currItem++;
+		if(li->currItem > (li->startShowItem + li->curHeight - 1)) {
+		    li->startShowItem = li->currItem - li->curHeight + 1;
+		    if(li->startShowItem + li->curHeight > li->numItems)
+			li->startShowItem = li->numItems - li->curHeight;
+		}
+		if(li->sb)
+		    newtScrollbarSet(li->sb, li->currItem + 1, li->numItems);
+		listboxDraw(co);
+	    }
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    break;
+	}
+	if ((ev.u.mouse.y >= co->top + li->bdyAdjust) &&
+	    (ev.u.mouse.y <= co->top + co->height - (li->bdyAdjust * 2)) &&
+	    (ev.u.mouse.x >= co->left + li->bdxAdjust) &&
+	    (ev.u.mouse.x <= co->left + co->width + (li->bdxAdjust * 2))) {
+	    li->currItem = li->startShowItem +
+		(ev.u.mouse.y - li->bdyAdjust - co->top);
+	    newtListboxRealSetCurrent(co);
+	    listboxDraw(co);
+	    if(co->callback) co->callback(co, co->callbackData);
+	    er.result = ER_SWALLOWED;
+	    break;
+	}
+    }
+
+    return er;
+}
+
+static void listboxDestroy(newtComponent co) {
+    struct listbox * li = co->data;
+    struct items * item, * nextitem;
+
+    nextitem = item = li->boxItems;
+
+    while (item != NULL) {
+	nextitem = item->next;
+	free(item->text);
+	free(item);
+	item = nextitem;
+    }
+
+    if (li->sb) li->sb->ops->destroy(li->sb);
+
+    free(li);
+    free(co);
+}
diff -Naur newt-0.52.2.orig/Makefile.in newt-0.52.2/Makefile.in
--- newt-0.52.2.orig/Makefile.in	2005-11-22 10:39:14.000000000 +0200
+++ newt-0.52.2/Makefile.in	2007-03-26 21:14:54.000000000 +0300
@@ -14,7 +14,7 @@
 
 WHIPTCLSO=whiptcl.so
 
-PROGS = test whiptail $(WHIPTCLSO) testgrid testtree showchars showkey
+PROGS = test whiptail testgrid testtree showchars showkey
 TESTOBJS = test.o
 NDIALOGOBJS = whiptail.o dialogboxes.o
 WHIPTCLOBJS = whiptcl.o dialogboxes.o
@@ -78,15 +78,15 @@
 whiptail: $(NDIALOGOBJS) $(LIBNEWTSH)
 	$(CC) -g -o whiptail $(NDIALOGOBJS) -L . -lnewt $(LIBS) -lpopt
 
-whiptcl.so: $(WHIPTCLOBJS) $(LIBNEWTSH)
-	$(CC) -shared $(SHCFLAGS) -o whiptcl.so $(WHIPTCLOBJS) -L . -lnewt  $(LIBTCL) -lslang -lpopt -lm
+#whiptcl.so: $(WHIPTCLOBJS) $(LIBNEWTSH)
+#	$(CC) -shared $(SHCFLAGS) -o whiptcl.so $(WHIPTCLOBJS) -L . -lnewt  $(LIBTCL) -lslang -lpopt -lm
 
 # Ensure dialogboxes is compiled -fPIC
 dialogboxes.o: dialogboxes.c
 	$(CC) $(CFLAGS) $(SHCFLAGS) -c dialogboxes.c
 
-whiptcl.o:   whiptcl.c
-	$(CC) -I/usr/include/tcl8.4 $(SHCFLAGS) $(CFLAGS) -c whiptcl.c
+#whiptcl.o:   whiptcl.c
+#	$(CC) -I/usr/include/tcl8.4 $(SHCFLAGS) $(CFLAGS) -c whiptcl.c
 
 
 $(LIBNEWT): $(LIBOBJS)
@@ -129,11 +129,11 @@
 	install -m 644 $(LIBNEWT) $(instroot)/$(libdir)
 	install -m 755 whiptail $(instroot)/$(bindir)
 
-install-sh: sharedlib $(WHIPTCLSO) _snackmodule.so
+install-sh: sharedlib _snackmodule.so
 	[ -d $(instroot)/$(libdir) ] || install -m 755 -d $(instroot)/$(libdir)
 	install -m 755 $(LIBNEWTSH) $(instroot)/$(libdir)
 	ln -sf $(LIBNEWTSH) $(instroot)/$(libdir)/libnewt.so
-	[ -n "$(WHIPTCLSO)" ] && install -m 755 whiptcl.so $(instroot)/$(libdir) || :
+#	[ -n "$(WHIPTCLSO)" ] && install -m 755 whiptcl.so $(instroot)/$(libdir) || :
 	for ver in $(PYTHONVERS) ; do \
 	   [ -d $(instroot)/$(libdir)/$$ver/site-packages ] || install -m 755 -d $(instroot)/$(libdir)/$$ver/site-packages ;\
 	   install -m 755 $$ver/_snackmodule.so $(instroot)/$(libdir)/$$ver/site-packages ;\
diff -Naur newt-0.52.2.orig/newt.c newt-0.52.2/newt.c
--- newt-0.52.2.orig/newt.c	2005-09-30 17:13:16.000000000 +0300
+++ newt-0.52.2/newt.c	2007-03-26 21:15:21.000000000 +0300
@@ -53,21 +53,21 @@
 	"red", "lightgray",			/* title fg, bg */
 	"lightgray", "red",			/* button fg, bg */
 	"red", "lightgray",			/* active button fg, bg */
-	"yellow", "blue",			/* checkbox fg, bg */
-	"blue", "brown",			/* active checkbox fg, bg */
-	"yellow", "blue",			/* entry box fg, bg */
+	"lightgray", "blue",			/* checkbox fg, bg */
+	"lightgray", "red",			/* active checkbox fg, bg */
+	"lightgray", "blue",			/* entry box fg, bg */
 	"blue", "lightgray",			/* label fg, bg */
 	"black", "lightgray",			/* listbox fg, bg */
-	"yellow", "blue",			/* active listbox fg, bg */
+	"lightgray", "blue",			/* active listbox fg, bg */
 	"black", "lightgray",			/* textbox fg, bg */
-	"lightgray", "black",			/* active textbox fg, bg */
+	"lightgray", "red",			/* active textbox fg, bg */
 	"white", "blue",			/* help line */
-	"yellow", "blue",			/* root text */
+	"lightgray", "blue",			/* root text */
 	"blue",					/* scale full */
 	"red",					/* scale empty */
 	"blue", "lightgray",			/* disabled entry fg, bg */
 	"black", "lightgray",			/* compact button fg, bg */
-	"yellow", "red",			/* active & sel listbox */
+	"lightgray", "red",			/* active & sel listbox */
 	"black", "brown"			/* selected listbox */
 };
 
@@ -184,12 +184,13 @@
 void trim_string(char *title, int chrs)
 {
 	char *p = title;
-	int ln = chrs;
+	int ln;
 	int x = 0,y = 0;
 	wchar_t tmp;
 	mbstate_t ps;
 
 	memset(&ps, 0, sizeof(ps));
+	ln = strlen(title);
 
 	while (*p) {
 		x = mbrtowc(&tmp, p, ln, &ps);
@@ -198,12 +199,13 @@
 			return;
 		}
 		y = wcwidth(tmp);
-		if (y > ln) {
+		if (y > chrs) {
 			*p = '\0';
 			return;
 		} else {
 			p += x;
-			ln -= y;
+			ln -= x;
+			chrs -= y;
 		}
 	}	
 }
@@ -610,14 +612,14 @@
 
 /**
  * Open a new window.
- * @param left. unsigned int Size; _not_ including border
- * @param top: unsigned int size, _not_ including border
+ * @param left. int Size; _not_ including border
+ * @param top: int size, _not_ including border
  * @param width unsigned int
  * @param height unsigned int
  * @param title - title string
  * @return zero on success (currently no errors reported)
  */
-int newtOpenWindow(unsigned int left, unsigned int top, 
+int newtOpenWindow(int left, int top, 
                    unsigned int width, unsigned int height,
 			  const char * title) {
     int j, row, col;
@@ -638,10 +640,10 @@
     currentWindow->height = height;
     currentWindow->title = title ? strdup(title) : NULL;
 
-    currentWindow->buffer = malloc(sizeof(SLsmg_Char_Type) * (width + 3) * (height + 3));
+    currentWindow->buffer = malloc(sizeof(SLsmg_Char_Type) * (width + 5) * (height + 3));
 
     row = top - 1;
-    col = left - 1;
+    col = left - 2;
     /* clip to the current screen bounds - msw */
     if (row < 0)
 	row = 0;
@@ -655,8 +657,8 @@
     for (j = 0; j < height + 3; j++, row++) {
 	SLsmg_gotorc(row, col);
 	SLsmg_read_raw(currentWindow->buffer + n,
-		       currentWindow->width + 3);
-	n += currentWindow->width + 3;
+		       currentWindow->width + 5);
+	n += currentWindow->width + 5;
     }
 
     newtTrashScreen();
@@ -708,14 +710,14 @@
  */
 int newtCenteredWindow(unsigned int width,unsigned int height, 
                        const char * title) {
-    unsigned int top, left;
+    int top, left;
 
-    top = (SLtt_Screen_Rows - height) / 2;
+    top = (int)(SLtt_Screen_Rows - height) / 2;
 
     /* I don't know why, but this seems to look better */
     if ((SLtt_Screen_Rows % 2) && (top % 2)) top--;
 
-    left = (SLtt_Screen_Cols - width) / 2;
+    left = (int)(SLtt_Screen_Cols - width) / 2;
 
     newtOpenWindow(left, top, width, height, title);
 
@@ -732,7 +734,7 @@
     row = col = 0;
 
     row = currentWindow->top - 1;
-    col = currentWindow->left - 1;
+    col = currentWindow->left - 2;
     if (row < 0)
 	row = 0;
     if (col < 0)
@@ -740,8 +742,8 @@
     for (j = 0; j < currentWindow->height + 3; j++, row++) {
 	SLsmg_gotorc(row, col);
 	SLsmg_write_raw(currentWindow->buffer + n,
-			currentWindow->width + 3);
-	n += currentWindow->width + 3;
+			currentWindow->width + 5);
+	n += currentWindow->width + 5;
     }
 
     free(currentWindow->buffer);
diff -Naur newt-0.52.2.orig/newt.c.orig newt-0.52.2/newt.c.orig
--- newt-0.52.2.orig/newt.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ newt-0.52.2/newt.c.orig	2007-03-26 21:14:43.000000000 +0300
@@ -0,0 +1,986 @@
+#include "config.h"
+
+#include <slang.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <termios.h>
+#include <unistd.h>
+#include <wchar.h>
+
+#ifdef HAVE_ALLOCA_H
+#include <alloca.h>
+#endif
+
+#include "newt.h"
+#include "newt_pr.h"
+
+struct Window {
+    int height, width, top, left;
+    SLsmg_Char_Type * buffer;
+    char * title;
+};
+
+struct keymap {
+    char * str;
+    int code;
+    char * tc;
+};
+
+static struct Window windowStack[20];
+static struct Window * currentWindow = NULL;
+
+static char * helplineStack[20];
+static char ** currentHelpline = NULL;
+
+static int cursorRow, cursorCol;
+static int needResize = 0;
+static int cursorOn = 1;
+static int trashScreen = 0;
+
+static const char * defaultHelpLine =
+"  <Tab>/<Alt-Tab> between elements   |  <Space> selects   |  <F12> next screen"
+;
+
+const struct newtColors newtDefaultColorPalette = {
+	"white", "blue", 			/* root fg, bg */
+	"black", "lightgray",			/* border fg, bg */
+	"black", "lightgray",			/* window fg, bg */
+	"white", "black",			/* shadow fg, bg */
+	"red", "lightgray",			/* title fg, bg */
+	"lightgray", "red",			/* button fg, bg */
+	"red", "lightgray",			/* active button fg, bg */
+	"lightgray", "blue",			/* checkbox fg, bg */
+	"lightgray", "red",			/* active checkbox fg, bg */
+	"lightgray", "blue",			/* entry box fg, bg */
+	"blue", "lightgray",			/* label fg, bg */
+	"black", "lightgray",			/* listbox fg, bg */
+	"lightgray", "blue",			/* active listbox fg, bg */
+	"black", "lightgray",			/* textbox fg, bg */
+	"lightgray", "red",			/* active textbox fg, bg */
+	"white", "blue",			/* help line */
+	"lightgray", "blue",			/* root text */
+	"blue",					/* scale full */
+	"red",					/* scale empty */
+	"blue", "lightgray",			/* disabled entry fg, bg */
+	"black", "lightgray",			/* compact button fg, bg */
+	"lightgray", "red",			/* active & sel listbox */
+	"black", "brown"			/* selected listbox */
+};
+
+static const struct keymap keymap[] = {
+	{ "\033OA", 		NEWT_KEY_UP, 		"ku" },
+	{ "\020", 		NEWT_KEY_UP, 		NULL }, /* emacs ^P */
+	{ "\033OB", 		NEWT_KEY_DOWN, 		"kd" },
+	{ "\016", 		NEWT_KEY_DOWN, 		NULL }, /* emacs ^N */
+	{ "\033OC", 		NEWT_KEY_RIGHT, 	"kr" },
+	{ "\006", 		NEWT_KEY_RIGHT, 	NULL }, /* emacs ^F */
+	{ "\033OD", 		NEWT_KEY_LEFT, 		"kl" },
+	{ "\002", 		NEWT_KEY_LEFT, 		NULL }, /* emacs ^B */
+	{ "\033OH",		NEWT_KEY_HOME, 		"kh" },
+	{ "\033[1~",		NEWT_KEY_HOME, 		NULL },
+	{ "\001",		NEWT_KEY_HOME, 		NULL }, /* emacs ^A */
+	{ "\033Ow",		NEWT_KEY_END, 		"kH" },
+        { "\033[4~",		NEWT_KEY_END, 		"@7" },
+        { "\005",		NEWT_KEY_END, 		NULL }, /* emacs ^E */
+
+	{ "\033[3~",		NEWT_KEY_DELETE,	"kD" },
+	{ "\004",		NEWT_KEY_DELETE,	NULL }, /* emacs ^D */
+	{ "\033[2~", 		NEWT_KEY_INSERT,        "kI" },
+
+	{ "\033\t",		NEWT_KEY_UNTAB,		"kB" },
+
+	{ "\033[5~",		NEWT_KEY_PGUP,		"kP" },
+	{ "\033[6~",		NEWT_KEY_PGDN,		"kN" },
+	{ "\033V",		NEWT_KEY_PGUP, 		NULL },
+	{ "\033v",		NEWT_KEY_PGUP, 		NULL },
+        { "\026",		NEWT_KEY_PGDN,		NULL },
+
+	{ "\033[[A",		NEWT_KEY_F1,		NULL },
+	{ "\033[[B",		NEWT_KEY_F2,		NULL },
+	{ "\033[[C",		NEWT_KEY_F3,		NULL },
+	{ "\033[[D",		NEWT_KEY_F4,		NULL },
+	{ "\033[[E",		NEWT_KEY_F5,		NULL },
+
+	{ "\033OP",		NEWT_KEY_F1,		NULL },
+	{ "\033OQ",		NEWT_KEY_F2,		NULL },
+	{ "\033OR",		NEWT_KEY_F3,		NULL },
+	{ "\033OS",		NEWT_KEY_F4,		NULL },
+
+	{ "\033[11~",		NEWT_KEY_F1,		"k1" },
+	{ "\033[12~",		NEWT_KEY_F2,		"k2" },
+	{ "\033[13~",		NEWT_KEY_F3,		"k3" },
+	{ "\033[14~",		NEWT_KEY_F4,		"k4" },
+	{ "\033[15~",		NEWT_KEY_F5,		"k5" },
+	{ "\033[17~",		NEWT_KEY_F6,		"k6" },
+	{ "\033[18~",		NEWT_KEY_F7,		"k7" },
+	{ "\033[19~",		NEWT_KEY_F8,		"k8" },
+	{ "\033[20~",		NEWT_KEY_F9,            "k9" },
+	{ "\033[21~",		NEWT_KEY_F10,		"k;" },
+	{ "\033[23~",		NEWT_KEY_F11,		"F1" },
+	{ "\033[24~",		NEWT_KEY_F12,		"F2" },
+	{ "\033",		NEWT_KEY_ESCAPE,	"@2" },
+        { "\033",		NEWT_KEY_ESCAPE,	"@9" },
+
+        { "\177",		NEWT_KEY_BKSPC,		NULL },
+        { "\010",		NEWT_KEY_BKSPC,		NULL },
+        
+	{ 0 },	/* LEAVE this one */
+};
+static void initKeymap();
+
+static const char ident[] = // ident friendly
+    "$Version: Newt windowing library v" VERSION " $"
+    "$Copyright: (C) 1996-2003 Red Hat, Inc. Written by Erik Troan $"
+    "$License: Lesser GNU Public License. $";
+
+static newtSuspendCallback suspendCallback = NULL;
+static void * suspendCallbackData = NULL;
+
+void newtSetSuspendCallback(newtSuspendCallback cb, void * data) {
+    suspendCallback = cb;
+    suspendCallbackData = data;
+}
+
+static void handleSigwinch(int signum) {
+    needResize = 1;
+}
+
+static int getkeyInterruptHook(void) {
+    return -1;
+}
+
+int _newt_wstrlen(const char *str, int len) {
+	mbstate_t ps;
+	wchar_t tmp;
+	int nchars = 0;
+	
+	if (!str) return 0;
+	if (!len) return 0;
+	if (len < 0) len = strlen(str);
+	memset(&ps,0,sizeof(mbstate_t));
+	while (len > 0) {
+		int x,y;
+		
+		x = mbrtowc(&tmp,str,len,&ps);
+		if (x >0) {
+		    	str += x;
+			len -= x;
+			y = wcwidth(tmp);
+			if (y>0)
+			  nchars+=y;
+		} else break;
+	}
+	return nchars;
+}
+
+/** Trim a string to fit 
+ * @param title - string. NULL will be inserted if necessary
+ * @param chrs  - available space. (character cells)
+ */
+void trim_string(char *title, int chrs)
+{
+	char *p = title;
+	int ln;
+	int x = 0,y = 0;
+	wchar_t tmp;
+	mbstate_t ps;
+
+	memset(&ps, 0, sizeof(ps));
+	ln = strlen(title);
+
+	while (*p) {
+		x = mbrtowc(&tmp, p, ln, &ps);
+		if (x < 0) { // error
+			*p = '\0';
+			return;
+		}
+		y = wcwidth(tmp);
+		if (y > chrs) {
+			*p = '\0';
+			return;
+		} else {
+			p += x;
+			ln -= x;
+			chrs -= y;
+		}
+	}	
+}
+
+static int getkey() {
+    int c;
+
+    while ((c = SLang_getkey()) == '\xC') { /* if Ctrl-L redraw whole screen */
+        SLsmg_touch_lines (0, SLtt_Screen_Rows - 1);
+        SLsmg_refresh();
+    }
+    return c;
+
+}
+
+void newtFlushInput(void) {
+    while (SLang_input_pending(0)) {
+	getkey();
+    }
+}
+
+/**
+ * @brief Refresh the screen
+ */
+void newtRefresh(void) {
+    SLsmg_refresh();
+}
+
+void newtSuspend(void) {
+    SLtt_set_cursor_visibility (1);
+    SLsmg_suspend_smg();
+    SLang_reset_tty();
+    SLtt_set_cursor_visibility (cursorOn);
+}
+
+/**
+ *  @brief Return after suspension.
+ *  @return 0 on success.
+ */
+int newtResume(void) {
+    SLsmg_resume_smg ();
+    SLsmg_refresh();
+    return SLang_init_tty(0, 0, 0);
+}
+
+void newtCls(void) {
+    SLsmg_set_color(NEWT_COLORSET_ROOT);
+    SLsmg_gotorc(0, 0);
+    SLsmg_erase_eos();
+
+    newtRefresh();
+}
+
+/**
+ * @brief Resize the screen
+ * @param redraw - boolean - should we redraw the screen?
+ */
+void newtResizeScreen(int redraw) {
+    SLtt_get_screen_size();
+    SLsmg_reinit_smg();
+    if (redraw) {
+        SLsmg_touch_lines (0, SLtt_Screen_Rows - 1);
+        newtRefresh();
+    }
+}
+
+/**
+ * @brief Initialize the newt library
+ * @return int - 0 for success, else < 0
+ */
+int newtInit(void) {
+    char * MonoValue, * MonoEnv = "NEWT_MONO";
+    const char *lang;
+    int ret;
+
+    if ((lang = getenv("LC_ALL")) == NULL)
+        if ((lang = getenv("LC_CTYPE")) == NULL)
+            if ((lang = getenv("LANG")) == NULL)
+                lang = "";
+    if (strstr (lang, ".euc") != NULL)
+	trashScreen = 1;
+
+    (void) strlen(ident);
+
+    SLtt_get_terminfo();
+    SLtt_get_screen_size();
+
+    MonoValue = getenv(MonoEnv);
+    if ( MonoValue == NULL ) {
+	SLtt_Use_Ansi_Colors = 1;
+    } else {
+	SLtt_Use_Ansi_Colors = 0;
+    }
+
+    if ((ret = SLsmg_init_smg()) < 0)
+	return ret;
+    if ((ret = SLang_init_tty(0, 0, 0)) < 0)
+	return ret;
+
+    newtSetColors(newtDefaultColorPalette);
+    newtCursorOff();
+    initKeymap();
+
+    /*memset(&sa, 0, sizeof(sa));
+    sa.sa_handler = handleSigwinch;
+    sigaction(SIGWINCH, &sa, NULL);*/
+
+    SLsignal_intr(SIGWINCH, handleSigwinch);
+    SLang_getkey_intr_hook = getkeyInterruptHook;
+
+    return 0;
+}
+
+/**
+ * @brief Closedown the newt library, tidying screen.
+ * @returns int , 0. (no errors reported)
+ */
+int newtFinished(void) {
+    SLsmg_gotorc(SLtt_Screen_Rows - 1, 0);
+    newtCursorOn();
+    SLsmg_refresh();
+    SLsmg_reset_smg();
+    SLang_reset_tty();
+
+    return 0;
+}
+
+/**
+ * @brief Set the colors used.
+ * @param colors - newtColor struct used.
+ */
+void newtSetColors(struct newtColors colors) {
+    if (!SLtt_Use_Ansi_Colors) {
+        int i;
+
+        for (i = 2; i < 25; i++)
+            SLtt_set_mono(i, NULL, 0);
+
+        SLtt_set_mono(NEWT_COLORSET_SELLISTBOX, NULL, SLTT_BOLD_MASK);
+
+        SLtt_set_mono(NEWT_COLORSET_ACTBUTTON, NULL, SLTT_REV_MASK);
+        SLtt_set_mono(NEWT_COLORSET_ACTCHECKBOX, NULL, SLTT_REV_MASK);
+        SLtt_set_mono(NEWT_COLORSET_ACTLISTBOX, NULL, SLTT_REV_MASK);
+        SLtt_set_mono(NEWT_COLORSET_ACTTEXTBOX, NULL, SLTT_REV_MASK);
+
+        SLtt_set_mono(NEWT_COLORSET_ACTSELLISTBOX, NULL, SLTT_REV_MASK | SLTT_BOLD_MASK);
+        
+        SLtt_set_mono(NEWT_COLORSET_DISENTRY, NULL, 0); // FIXME
+        SLtt_set_mono(NEWT_COLORSET_FULLSCALE, NULL, SLTT_ULINE_MASK | SLTT_REV_MASK);
+        SLtt_set_mono(NEWT_COLORSET_EMPTYSCALE, NULL, SLTT_ULINE_MASK);
+        return;
+    }
+    SLtt_set_color(NEWT_COLORSET_ROOT, "", colors.rootFg, colors.rootBg);
+    SLtt_set_color(NEWT_COLORSET_BORDER, "", colors.borderFg, colors.borderBg);
+    SLtt_set_color(NEWT_COLORSET_WINDOW, "", colors.windowFg, colors.windowBg);
+    SLtt_set_color(NEWT_COLORSET_SHADOW, "", colors.shadowFg, colors.shadowBg);
+    SLtt_set_color(NEWT_COLORSET_TITLE, "", colors.titleFg, colors.titleBg);
+    SLtt_set_color(NEWT_COLORSET_BUTTON, "", colors.buttonFg, colors.buttonBg);
+    SLtt_set_color(NEWT_COLORSET_ACTBUTTON, "", colors.actButtonFg,
+			colors.actButtonBg);
+    SLtt_set_color(NEWT_COLORSET_CHECKBOX, "", colors.checkboxFg,
+			colors.checkboxBg);
+    SLtt_set_color(NEWT_COLORSET_ACTCHECKBOX, "", colors.actCheckboxFg,
+			colors.actCheckboxBg);
+    SLtt_set_color(NEWT_COLORSET_ENTRY, "", colors.entryFg, colors.entryBg);
+    SLtt_set_color(NEWT_COLORSET_LABEL, "", colors.labelFg, colors.labelBg);
+    SLtt_set_color(NEWT_COLORSET_LISTBOX, "", colors.listboxFg,
+			colors.listboxBg);
+    SLtt_set_color(NEWT_COLORSET_ACTLISTBOX, "", colors.actListboxFg,
+			colors.actListboxBg);
+    SLtt_set_color(NEWT_COLORSET_TEXTBOX, "", colors.textboxFg,
+			colors.textboxBg);
+    SLtt_set_color(NEWT_COLORSET_ACTTEXTBOX, "", colors.actTextboxFg,
+			colors.actTextboxBg);
+    SLtt_set_color(NEWT_COLORSET_HELPLINE, "", colors.helpLineFg,
+			colors.helpLineBg);
+    SLtt_set_color(NEWT_COLORSET_ROOTTEXT, "", colors.rootTextFg,
+			colors.rootTextBg);
+
+    SLtt_set_color(NEWT_COLORSET_EMPTYSCALE, "", "white",
+			colors.emptyScale);
+    SLtt_set_color(NEWT_COLORSET_FULLSCALE, "", "white",
+			colors.fullScale);
+    SLtt_set_color(NEWT_COLORSET_DISENTRY, "", colors.disabledEntryFg,
+			colors.disabledEntryBg);
+
+    SLtt_set_color(NEWT_COLORSET_COMPACTBUTTON, "", colors.compactButtonFg,
+			colors.compactButtonBg);
+
+    SLtt_set_color(NEWT_COLORSET_ACTSELLISTBOX, "", colors.actSelListboxFg,
+		   colors.actSelListboxBg);
+    SLtt_set_color(NEWT_COLORSET_SELLISTBOX, "", colors.selListboxFg,
+		   colors.selListboxBg);
+}
+
+/* Keymap handling - rewritten by Henning Makholm <henning@makholm.net>,
+ * November 2003.
+ */
+
+struct kmap_trie_entry {
+    char c ;   /* character got from terminal */
+    int code;  /* newt key, or 0 if c does not make a complete sequence */
+    struct kmap_trie_entry *contseq; /* sub-trie for character following c */
+    struct kmap_trie_entry *next;    /* try this if char received != c */
+};
+/* Here are some static entries that will help in handling esc O foo and
+   esc [ foo as variants of each other: */
+static struct kmap_trie_entry
+    kmap_trie_escO     = { 'O', 0, 0, 0 },
+    kmap_trie_escBrack = { '[', 0, 0, &kmap_trie_escO },
+    kmap_trie_root     = { '\033', 0, &kmap_trie_escBrack, 0 };
+static int keyreader_buf_len = 10 ;
+static unsigned char default_keyreader_buf[10];
+static unsigned char *keyreader_buf = default_keyreader_buf;
+
+#if 0 /* for testing of the keymap manipulation code */
+static void dumpkeys_recursive(struct kmap_trie_entry *curr, int i, FILE *f) {
+    int j, ps ;
+    char seen[256]={0};
+    if( curr && i >= keyreader_buf_len ) {
+        fprintf(f,"ARGH! Too long sequence!\n") ;
+        return ;
+    }
+    for(;curr;curr=curr->next) {
+        keyreader_buf[i] = curr->c ;
+        ps = seen[(unsigned char)curr->c]++ ;
+        if( ps || curr->code || (!curr->code && !curr->contseq) ) {
+            for(j=0;j<=i;j++) {
+                if( keyreader_buf[j] > 32 && keyreader_buf[j]<127 &&
+                    keyreader_buf[j] != '^' && keyreader_buf[j] != '\\' )
+                    fprintf(f,"%c",keyreader_buf[j]);
+                else if( keyreader_buf[j] > 0 && keyreader_buf[j]<=32 )
+                    fprintf(f,"^%c",keyreader_buf[j] + 0x40);
+                else
+                    fprintf(f,"\\%03o",
+                            (unsigned)(unsigned char)keyreader_buf[j]);
+            }
+            if( curr->code )
+                fprintf(f,": 0x%X\n",curr->code);
+            else
+                fprintf(f,": (just keymap)\n");
+        }
+        dumpkeys_recursive(curr->contseq,i+1,f);
+    }
+}
+static void dump_keymap(void) {
+    FILE *f = fopen("newt.keydump","wt");
+    if (f) {
+        dumpkeys_recursive(&kmap_trie_root,0,f);
+        fclose(f);
+    }
+}
+#endif
+
+/* newtBindKey may overwrite a binding that is there already */
+static void newtBindKey(char *keyseq, int meaning) {
+    struct kmap_trie_entry *root = &kmap_trie_root ;
+    struct kmap_trie_entry **curptr = &root ;
+
+    /* Try to make sure the common matching buffer is long enough. */
+    if( strlen(keyseq) > keyreader_buf_len ) {
+        int i = strlen(keyseq)+10;
+        unsigned char *newbuf = malloc(i);
+        if (newbuf) {
+            if (keyreader_buf != default_keyreader_buf)
+                free(keyreader_buf);
+            keyreader_buf = newbuf;
+            keyreader_buf_len = i;
+        }
+    }
+    
+    if (*keyseq == 0) return; /* binding the empty sequence is meaningless */
+    
+    while(1) {
+        while ((*curptr) && (*curptr)->c != *keyseq)
+            curptr = &(*curptr)->next;
+        if ((*curptr)==0) {
+            struct kmap_trie_entry* fresh
+                =  calloc(strlen(keyseq),sizeof(struct kmap_trie_entry));
+            if (fresh == 0) return; /* despair! */
+            *curptr = fresh;
+            while (keyseq[1]) {
+                fresh->contseq = fresh+1;
+                (fresh++)->c = *(keyseq++);
+            }
+            fresh->c = *keyseq;
+            fresh->code = meaning;
+            return;
+        }
+        if (keyseq[1]==0) {
+            (*curptr)->code = meaning;
+            return;
+        } else {
+            curptr = &(*curptr)->contseq;
+            keyseq++;
+        }
+    }      
+}
+
+/* This function recursively inserts all entries in the "to" trie into
+   corresponding positions in the "from" trie, except positions that
+   are already defined in the "from" trie. */
+static void kmap_trie_fallback(struct kmap_trie_entry *to,
+                               struct kmap_trie_entry **from) {
+    if (*from == NULL)
+        *from = to ;
+    if (*from == to)
+        return ;
+    for (;to!=NULL;to=to->next) {
+        struct kmap_trie_entry **fromcopy = from ;
+        while ((*fromcopy) && (*fromcopy)->c != to->c)
+            fromcopy = &(*fromcopy)->next ;
+        if (*fromcopy) {
+            if ((*fromcopy)->code == 0)
+                (*fromcopy)->code = to->code;
+            kmap_trie_fallback(to->contseq, &(*fromcopy)->contseq);
+        } else {
+            *fromcopy = malloc(sizeof(struct kmap_trie_entry));
+            if (*fromcopy) {
+                **fromcopy = *to ;
+                (*fromcopy)->next = 0 ;
+            }
+        }
+    }
+}
+
+int newtGetKey(void) {
+    int key;
+    unsigned char *chptr = keyreader_buf, *lastmatch;
+    int lastcode;
+    struct kmap_trie_entry *curr = &kmap_trie_root;
+
+    do {
+	key = getkey();
+	if (key == SLANG_GETKEY_ERROR) {
+	    /* Either garbage was read, or stdin disappeared
+	     * (the parent terminal was proably closed)
+	     * if the latter, die.
+	     */
+	    if (feof(stdin))
+		    exit(1);
+	    if (needResize) {
+                needResize = 0;
+		return NEWT_KEY_RESIZE;
+            }
+
+	    /* ignore other signals */
+	    continue;
+	}
+
+	if (key == NEWT_KEY_SUSPEND && suspendCallback)
+	    suspendCallback(suspendCallbackData);
+    } while (key == NEWT_KEY_SUSPEND);
+
+    /* Read more characters, matching against the trie as we go */
+    lastcode = *chptr = key;
+    lastmatch = chptr ;
+    while(1) {
+         while (curr->c != key) {
+             curr = curr->next ;
+             if (curr==NULL) goto break2levels;
+         }
+         if (curr->code) {
+             lastcode = curr->code;
+             lastmatch = chptr;
+         }
+         curr = curr->contseq;
+         if (curr==NULL) break;
+
+         if (SLang_input_pending(5) <= 0)
+             break;
+
+         if (chptr==keyreader_buf+keyreader_buf_len-1) break;
+         *++chptr = key = getkey();
+    }
+   break2levels:
+
+      /* The last time the trie matched was at position lastmatch. Back
+       * up if we have read too many characters. */
+      while (chptr > lastmatch)
+          SLang_ungetkey(*chptr--);
+    
+      return lastcode;
+}
+
+/**
+ * @brief Wait for a keystroke
+ */
+void newtWaitForKey(void) {
+    newtRefresh();
+
+    getkey();
+    newtClearKeyBuffer();
+}
+
+/**
+ * @brief Clear the keybuffer
+ */
+void newtClearKeyBuffer(void) {
+    while (SLang_input_pending(1)) {
+	getkey();
+    }
+}
+
+/**
+ * Open a new window.
+ * @param left. unsigned int Size; _not_ including border
+ * @param top: unsigned int size, _not_ including border
+ * @param width unsigned int
+ * @param height unsigned int
+ * @param title - title string
+ * @return zero on success (currently no errors reported)
+ */
+int newtOpenWindow(unsigned int left, unsigned int top, 
+                   unsigned int width, unsigned int height,
+			  const char * title) {
+    int j, row, col;
+    int n;
+    int i;
+
+    newtFlushInput();
+
+    if (!currentWindow) {
+	currentWindow = windowStack;
+    } else {
+	currentWindow++;
+    }
+
+    currentWindow->left = left;
+    currentWindow->top = top;
+    currentWindow->width = width;
+    currentWindow->height = height;
+    currentWindow->title = title ? strdup(title) : NULL;
+
+    currentWindow->buffer = malloc(sizeof(SLsmg_Char_Type) * (width + 5) * (height + 3));
+
+    row = top - 1;
+    col = left - 2;
+    /* clip to the current screen bounds - msw */
+    if (row < 0)
+	row = 0;
+    if (col < 0)
+	col = 0;
+    if (left + width > SLtt_Screen_Cols)
+	width = SLtt_Screen_Cols - left;
+    if (top + height > SLtt_Screen_Rows)
+	height = SLtt_Screen_Rows - top;
+    n = 0;
+    for (j = 0; j < height + 3; j++, row++) {
+	SLsmg_gotorc(row, col);
+	SLsmg_read_raw(currentWindow->buffer + n,
+		       currentWindow->width + 5);
+	n += currentWindow->width + 5;
+    }
+
+    newtTrashScreen();
+
+    SLsmg_set_color(NEWT_COLORSET_BORDER);
+    SLsmg_set_char_set(1);
+    SLsmg_draw_box(top - 1, left - 1, height + 2, width + 2);
+    SLsmg_set_char_set(0);
+
+    if (currentWindow->title) {
+	trim_string (currentWindow->title, width-4);
+	i = wstrlen(currentWindow->title,-1) + 4;
+	i = ((width - i) / 2) + left;
+	SLsmg_gotorc(top - 1, i);
+	SLsmg_set_char_set(1);
+	SLsmg_write_char(SLSMG_RTEE_CHAR);
+	SLsmg_set_char_set(0);
+	SLsmg_write_char(' ');
+	SLsmg_set_color(NEWT_COLORSET_TITLE);
+	SLsmg_write_string((char *)currentWindow->title);
+	SLsmg_set_color(NEWT_COLORSET_BORDER);
+	SLsmg_write_char(' ');
+	SLsmg_set_char_set(1);
+	SLsmg_write_char(SLSMG_LTEE_CHAR);
+	SLsmg_set_char_set(0);
+    }
+
+    SLsmg_set_color(NEWT_COLORSET_WINDOW);
+    SLsmg_fill_region(top, left, height, width, ' ');
+
+    SLsmg_set_color(NEWT_COLORSET_SHADOW);
+    SLsmg_fill_region(top + height + 1, left, 1, width + 2, ' ');
+    SLsmg_fill_region(top, left + width + 1, height + 1, 1, ' ');
+
+    for (i = top; i < (top + height + 1); i++) {
+	SLsmg_gotorc(i, left + width + 1);
+	SLsmg_write_string(" ");
+    }
+
+    return 0;
+}
+
+/**
+ * @brief Draw a centered window.
+ * @param width - width in char cells
+ * @param height - no. of char cells.
+ * @param title - fixed title
+ * @returns 0. No errors reported
+ */
+int newtCenteredWindow(unsigned int width,unsigned int height, 
+                       const char * title) {
+    unsigned int top, left;
+
+    top = (SLtt_Screen_Rows - height) / 2;
+
+    /* I don't know why, but this seems to look better */
+    if ((SLtt_Screen_Rows % 2) && (top % 2)) top--;
+
+    left = (SLtt_Screen_Cols - width) / 2;
+
+    newtOpenWindow(left, top, width, height, title);
+
+    return 0;
+}
+
+/**
+ * @brief Remove the top window
+ */
+void newtPopWindow(void) {
+    int j, row, col;
+    int n = 0;
+
+    row = col = 0;
+
+    row = currentWindow->top - 1;
+    col = currentWindow->left - 2;
+    if (row < 0)
+	row = 0;
+    if (col < 0)
+	col = 0;
+    for (j = 0; j < currentWindow->height + 3; j++, row++) {
+	SLsmg_gotorc(row, col);
+	SLsmg_write_raw(currentWindow->buffer + n,
+			currentWindow->width + 5);
+	n += currentWindow->width + 5;
+    }
+
+    free(currentWindow->buffer);
+    free(currentWindow->title);
+
+    if (currentWindow == windowStack)
+	currentWindow = NULL;
+    else
+	currentWindow--;
+
+    SLsmg_set_char_set(0);
+
+    newtTrashScreen();
+
+    newtRefresh();
+}
+
+void newtGetWindowPos(int * x, int * y) {
+    if (currentWindow) {
+	*x = currentWindow->left;
+	*y = currentWindow->top;
+    } else
+	*x = *y = 0;
+}
+
+void newtGetrc(int * row, int * col) {
+   *row = cursorRow;
+   *col = cursorCol;
+}
+
+void newtGotorc(int newRow, int newCol) {
+    if (currentWindow) {
+	newRow += currentWindow->top;
+	newCol += currentWindow->left;
+    }
+
+    cursorRow = newRow;
+    cursorCol = newCol;
+    SLsmg_gotorc(cursorRow, cursorCol);
+}
+
+void newtDrawBox(int left, int top, int width, int height, int shadow) {
+    if (currentWindow) {
+	top += currentWindow->top;
+	left += currentWindow->left;
+    }
+
+    SLsmg_draw_box(top, left, height, width);
+
+    if (shadow) {
+	SLsmg_set_color(NEWT_COLORSET_SHADOW);
+	SLsmg_fill_region(top + height, left + 1, 1, width - 1, ' ');
+	SLsmg_fill_region(top + 1, left + width, height, 1, ' ');
+    }
+}
+
+void newtClearBox(int left, int top, int width, int height) {
+    if (currentWindow) {
+	top += currentWindow->top;
+	left += currentWindow->left;
+    }
+
+    SLsmg_fill_region(top, left, height, width, ' ');
+}
+
+static void initKeymap(void) {
+    const struct keymap * curr;
+
+    /* First bind built-in default bindings. They may be shadowed by
+       the termcap entries that get bound later. */
+    for (curr = keymap; curr->code; curr++) {
+        if (curr->str)
+            newtBindKey(curr->str,curr->code);
+    }
+
+    /* Then bind strings from termcap entries */
+    for (curr = keymap; curr->code; curr++) {
+	if (curr->tc) {
+            char *pc = SLtt_tgetstr(curr->tc);
+            if (pc) {
+                newtBindKey(pc,curr->code);
+            }
+        }
+    }
+
+    /* Finally, invent lowest-priority keybindings that correspond to
+       searching for esc-O-foo if esc-[-foo was not found and vice
+       versa.  That is needed because of strong confusion among
+       different emulators of VTxxx terminals; some terminfo/termcap
+       descriptions are apparently written by people who were not
+       aware of the differences between "applicataion" and "terminal"
+       keypad modes. Or perhaps they were, but tried to make their
+       description work with a program that puts the keyboard in the
+       wrong emulation mode. In short, one needs this: */
+    kmap_trie_fallback(kmap_trie_escO.contseq, &kmap_trie_escBrack.contseq);
+    kmap_trie_fallback(kmap_trie_escBrack.contseq, &kmap_trie_escO.contseq);
+}
+
+/**
+ * @brief Delay for a specified number of usecs
+ * @param int - number of usecs to wait for.
+ */
+void newtDelay(unsigned int usecs) {
+    fd_set set;
+    struct timeval tv;
+
+    FD_ZERO(&set);
+
+    tv.tv_sec = usecs / 1000000;
+    tv.tv_usec = usecs % 1000000;
+
+    select(0, &set, &set, &set, &tv);
+}
+
+struct eventResult newtDefaultEventHandler(newtComponent c,
+					   struct event ev) {
+    struct eventResult er;
+
+    er.result = ER_IGNORED;
+    return er;
+}
+
+void newtRedrawHelpLine(void) {
+    char * buf;
+
+    SLsmg_set_color(NEWT_COLORSET_HELPLINE);
+
+    if (currentHelpline) {
+	/* buffer size needs to be wide enough to hold all the multibyte
+	   currentHelpline + all the single byte ' ' to fill the line */
+	int wlen = wstrlen(*currentHelpline, -1);
+	int len;
+
+	if (wlen > SLtt_Screen_Cols)
+	    wlen = SLtt_Screen_Cols;
+	len = strlen(*currentHelpline) + (SLtt_Screen_Cols - wlen);
+	buf = alloca(len + 1);
+	memset(buf, ' ', len);
+	memcpy(buf, *currentHelpline, strlen(*currentHelpline));
+	buf[len] = '\0';
+    } else {
+	buf = alloca(SLtt_Screen_Cols + 1);
+	memset(buf, ' ', SLtt_Screen_Cols);
+	buf[SLtt_Screen_Cols] = '\0';
+    }
+    SLsmg_gotorc(SLtt_Screen_Rows - 1, 0);
+    SLsmg_write_string(buf);
+}
+
+void newtPushHelpLine(const char * text) {
+    if (!text)
+	text = defaultHelpLine;
+
+    if (currentHelpline)
+	(*(++currentHelpline)) = strdup(text);
+    else {
+	currentHelpline = helplineStack;
+	*currentHelpline = strdup(text);
+    }
+
+    newtRedrawHelpLine();
+}
+
+void newtPopHelpLine(void) {
+    if (!currentHelpline) return;
+
+    free(*currentHelpline);
+    if (currentHelpline == helplineStack)
+	currentHelpline = NULL;
+    else
+	currentHelpline--;
+
+    newtRedrawHelpLine();
+}
+
+void newtDrawRootText(int col, int row, const char * text) {
+    SLsmg_set_color(NEWT_COLORSET_ROOTTEXT);
+
+    if (col < 0) {
+	col = SLtt_Screen_Cols + col;
+    }
+
+    if (row < 0) {
+	row = SLtt_Screen_Rows + row;
+    }
+
+    SLsmg_gotorc(row, col);
+    SLsmg_write_string((char *)text);
+}
+
+int newtSetFlags(int oldFlags, int newFlags, enum newtFlagsSense sense) {
+    switch (sense) {
+      case NEWT_FLAGS_SET:
+	return oldFlags | newFlags;
+
+      case NEWT_FLAGS_RESET:
+	return oldFlags & (~newFlags);
+
+      case NEWT_FLAGS_TOGGLE:
+	return oldFlags ^ newFlags;
+
+      default:
+	return oldFlags;
+    }
+}
+
+void newtBell(void)
+{
+    SLtt_beep();
+}
+
+void newtGetScreenSize(int * cols, int * rows) {
+    if (rows) *rows = SLtt_Screen_Rows;
+    if (cols) *cols = SLtt_Screen_Cols;
+}
+
+void newtDefaultPlaceHandler(newtComponent c, int newLeft, int newTop) {
+    c->left = newLeft;
+    c->top = newTop;
+}
+
+void newtDefaultMappedHandler(newtComponent c, int isMapped) {
+    c->isMapped = isMapped;
+}
+
+void newtCursorOff(void) {
+    cursorOn = 0;
+    SLtt_set_cursor_visibility (cursorOn);
+}
+
+void newtCursorOn(void) {
+    cursorOn = 1;
+    SLtt_set_cursor_visibility (cursorOn);
+}
+
+void newtTrashScreen(void) {
+    if (trashScreen)
+	SLsmg_touch_lines (0, SLtt_Screen_Rows - 1);
+}
+     
diff -Naur newt-0.52.2.orig/newt.h newt-0.52.2/newt.h
--- newt-0.52.2.orig/newt.h	2005-09-21 12:32:01.000000000 +0300
+++ newt-0.52.2/newt.h	2007-03-26 21:15:21.000000000 +0300
@@ -115,7 +115,7 @@
 void newtClearKeyBuffer(void);
 void newtDelay(unsigned int usecs);
 /* top, left are *not* counting the border */
-int newtOpenWindow(unsigned int left,unsigned int top, 
+int newtOpenWindow(int left,int top, 
 		   unsigned int width,unsigned  int height, 
  		  const char * title);
 int newtCenteredWindow(unsigned int width,unsigned int height, const char * title);
diff -Naur newt-0.52.2.orig/newt_pr.h newt-0.52.2/newt_pr.h
--- newt-0.52.2.orig/newt_pr.h	2005-09-30 17:05:55.000000000 +0300
+++ newt-0.52.2/newt_pr.h	2007-03-26 21:14:43.000000000 +0300
@@ -82,5 +82,6 @@
 
 int _newt_wstrlen(const char *str, int len);
 #define wstrlen(str,len) _newt_wstrlen((str),(len))
+void trim_string(char *title, int chrs);
 
 #endif /* H_NEWT_PR */
diff -Naur newt-0.52.2.orig/popcorn.py newt-0.52.2/popcorn.py
--- newt-0.52.2.orig/popcorn.py	2000-05-16 19:54:02.000000000 +0300
+++ newt-0.52.2/popcorn.py	2007-03-26 21:15:10.000000000 +0300
@@ -4,7 +4,6 @@
 import sys
 
 def help(screen, text):
-    raise ValueError, "foo"
     ButtonChoiceWindow(screen, "Help", text, help = "Help on help")
 
 t = TextboxReflowed(25, "Some text which needs to be wrapped at a good place.")
diff -Naur newt-0.52.2.orig/scrollbar.c newt-0.52.2/scrollbar.c
--- newt-0.52.2.orig/scrollbar.c	2002-06-27 05:17:46.000000000 +0300
+++ newt-0.52.2/scrollbar.c	2007-03-26 21:16:03.000000000 +0300
@@ -47,7 +47,7 @@
     sb = malloc(sizeof(*sb));
     co->data = sb;
 
-    if (!strcmp(getenv("TERM"), "linux") && height >= 2) {
+    if (height >= 2) {
 	sb->arrows = 1;
 	sb->curr = 1;
     } else {
@@ -100,7 +100,7 @@
 
 static void sbDrawThumb(newtComponent co, int isOn) {
     struct scrollbar * sb = co->data;
-    SLtt_Char_Type ch = isOn ? '#' : SLSMG_CKBRD_CHAR;
+    SLtt_Char_Type ch = isOn ? SLSMG_BLOCK_CHAR : SLSMG_CKBRD_CHAR;
 
     if (!co->isMapped) return;
 
diff -Naur newt-0.52.2.orig/textbox.c newt-0.52.2/textbox.c
--- newt-0.52.2.orig/textbox.c	2005-09-30 17:05:55.000000000 +0300
+++ newt-0.52.2/textbox.c	2007-03-26 21:16:24.000000000 +0300
@@ -15,9 +15,10 @@
     char *blankline;
     int linesAlloced;
     int doWrap;
-    newtComponent sb;
+    newtComponent sb_act, sb;
     int topLine;
     int textWidth;
+    int isActive;
 };
 
 static char * expandTabs(const char * text);
@@ -43,8 +44,10 @@
     struct textbox * tb = co->data;
 
     co->isMapped = isMapped;
-    if (tb->sb)
+    if (tb->sb) {
 	tb->sb->ops->mapped(tb->sb, isMapped);
+	tb->sb_act->ops->mapped(tb->sb_act, isMapped);
+    }
 }
 
 static void textboxPlace(newtComponent co, int newLeft, int newTop) {
@@ -53,8 +56,10 @@
     co->top = newTop;
     co->left = newLeft;
 
-    if (tb->sb)
+    if (tb->sb) {
 	tb->sb->ops->place(tb->sb, co->left + co->width - 1, co->top);
+	tb->sb_act->ops->place(tb->sb_act, co->left + co->width - 1, co->top);
+    }
 }
 
 void newtTextboxSetHeight(newtComponent co, int height) {
@@ -107,16 +112,20 @@
     tb->lines = NULL;
     tb->topLine = 0;
     tb->textWidth = width;
+    tb->isActive = 0;
     tb->blankline = malloc(width+1);
     memset(tb->blankline,' ',width);
     tb->blankline[width] = '\0';
 
     if (flags & NEWT_FLAG_SCROLL) {
 	co->width += 2;
+	tb->sb_act = newtVerticalScrollbar(co->left + co->width - 1, co->top, 
+			   co->height, COLORSET_ACTTEXTBOX, COLORSET_TEXTBOX);
 	tb->sb = newtVerticalScrollbar(co->left + co->width - 1, co->top, 
 			   co->height, COLORSET_TEXTBOX, COLORSET_TEXTBOX);
+	co->takesFocus = 1;
     } else {
-	tb->sb = NULL;
+	tb->sb_act = tb->sb = NULL;
     }
 
     return co;
@@ -342,8 +351,13 @@
 
     if (tb->sb) {
 	size = tb->numLines - c->height;
-	newtScrollbarSet(tb->sb, tb->topLine, size ? size : 0);
-	tb->sb->ops->draw(tb->sb);
+	if (tb->isActive) {
+		newtScrollbarSet(tb->sb_act, tb->topLine, size ? size : 0);
+		tb->sb_act->ops->draw(tb->sb_act);
+	} else {
+		newtScrollbarSet(tb->sb, tb->topLine, size ? size : 0);
+		tb->sb->ops->draw(tb->sb);
+	}
     }
 
     SLsmg_set_color(NEWT_COLORSET_TEXTBOX);
@@ -363,7 +377,11 @@
 
     er.result = ER_IGNORED;
 
-    if (ev.when == EV_EARLY && ev.event == EV_KEYPRESS && tb->sb) {
+    if (!tb->sb || ev.when == EV_EARLY || ev.when == EV_LATE)
+	return er;
+
+    switch(ev.event) {
+      case EV_KEYPRESS:
 	newtTrashScreen();
 	switch (ev.u.key) {
 	  case NEWT_KEY_UP:
@@ -395,8 +413,8 @@
 	    er.result = ER_SWALLOWED;
 	    break;
 	}
-    }
-    if (ev.when == EV_EARLY && ev.event == EV_MOUSE && tb->sb) {
+	break;
+      case EV_MOUSE:
 	/* Top scroll arrow */
 	if (ev.u.mouse.x == co->width && ev.u.mouse.y == co->top) {
 	    if (tb->topLine) tb->topLine--;
@@ -412,6 +430,17 @@
 	    
 	    er.result = ER_SWALLOWED;
 	}
+	break;
+      case EV_FOCUS:
+	tb->isActive = 1;
+	textboxDraw(co);
+	er.result = ER_SWALLOWED;
+	break;
+      case EV_UNFOCUS:
+	tb->isActive = 0;
+	textboxDraw(co);
+	er.result = ER_SWALLOWED;
+	break;
     }
     return er;
 }
