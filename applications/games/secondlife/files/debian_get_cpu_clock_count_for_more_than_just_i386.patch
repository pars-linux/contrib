diff -urNad linden~/indra/llcommon/llfasttimer.cpp linden/indra/llcommon/llfasttimer.cpp
--- linden~/indra/llcommon/llfasttimer.cpp	2007-05-06 03:14:25.000000000 +1000
+++ linden/indra/llcommon/llfasttimer.cpp	2007-05-06 03:18:31.000000000 +1000
@@ -37,6 +37,7 @@
 #include <time.h>
 #include <sys/time.h>
 #include <sched.h>
+#include <boost/lexical_cast.hpp>
 
 #elif LL_DARWIN
 #	include <time.h>
@@ -92,13 +93,42 @@
 
 
 #if LL_LINUX
+#if defined(__i386__)
 U64 get_cpu_clock_count()
 {
 	U64 x;
 	__asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
 	return x;
 }
-#endif
+#elif defined(__amd64__)
+// For reason as to why this is different from __i386__, see the following:
+// http://www.gelato.unsw.edu.au/IA64wiki/rdtscOnAmd64
+U64 get_cpu_clock_count()
+{
+	U64 x, y;
+	__asm__ volatile (".byte 0x0f, 0x31" : "=a" (x), "=d" (y));
+	return ((U64)y << 32) | x;
+}
+#elif defined(__powerpc__)
+// Courtesy of Segher Boessenkool over IRC. ^_^
+// Segher claims this is too simple to by copyrightable.
+// The actual algoritm is in MPCFPE32B.pdf 2.21, "Programming Environments
+// Manual for 32-bit Implementations of the PowerPC Architecture" thanks
+// to libavcodec for the referral.
+U64 get_cpu_clock_count()
+{
+	U32 lo, hi, dum;
+	asm volatile ("0: mftbu %0; mftb %1; mftbu %2; cmplw %0,%2; bne 0b" : "=r"(hi), "=r"(lo), "=r"(dum) /*:: "memory"*/ ); 
+	return ((U64)hi << 32) | lo;
+}
+#else // !( defined(__i386__) || defined(__amd64__) || defined(__powerpc__) )
+#warning "get_cpu_clock_count falling back to gettimeofday implementation"
+U64 get_cpu_clock_count()
+{
+	return get_clock_count();
+}
+#endif // defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+#endif // LL_LINUX
 
 #if LL_DARWIN
 //
@@ -115,13 +145,34 @@
 //////////////////////////////////////////////////////////////////////////////
 
 //static
-#if LL_LINUX || LL_DARWIN
-// Both Linux and Mac use gettimeofday for accurate time
+#if LL_LINUX
+extern LLCPUInfo gSysCPU;
+#if ( defined(__i386__) || defined(__amd64__) )
+U64 LLFastTimer::countsPerSecond()
+{
+	return boost::lexical_cast<float>(gSysCPU.getInfoLine( "cpu Mhz" )) * 1000000;
+}
+#elif defined(__powerpc__)
+U64 LLFastTimer::countsPerSecond()
+{
+	return boost::lexical_cast<U64>(gSysCPU.getInfoLine( "timebase" ));
+}
+#else // LL_LINUX && !( defined(__i386__) || defined(__amd64__) || defined(__powerpc__) )
+// Linux falls back to gettimeofday-based code
 U64 LLFastTimer::countsPerSecond()
 {
 	return 1000000; // microseconds, so 1 Mhz.
 }
-#else
+#endif // LL_LINUX && *
+#elif LL_DARWIN
+// Mac uses gettimeofday for accurate time
+// If PowerPC Mac starts using the tb register, sysctlbyname's
+// hw.tbfrequency will give this value.
+U64 LLFastTimer::countsPerSecond()
+{
+	return 1000000; // microseconds, so 1 Mhz.
+}
+#else // LL_WINDOWS
 U64 LLFastTimer::countsPerSecond()
 {
 	if (!sCPUClockFrequency)
diff -urNad linden~/indra/llcommon/llsys.cpp linden/indra/llcommon/llsys.cpp
--- linden~/indra/llcommon/llsys.cpp	2007-05-06 03:14:25.000000000 +1000
+++ linden/indra/llcommon/llsys.cpp	2007-05-06 03:19:22.000000000 +1000
@@ -308,14 +308,42 @@
 	mHasSSE2 = (info->_Ext.SSE2_StreamingSIMD2_Extensions != 0);
 	mCPUMhz = (S32)(proc.GetCPUFrequency(50)/1000000.0);
 	mFamily.assign( info->strFamily );
+#ifdef LL_LINUX
+	// *NOTE: This works on linux. What will it do on other systems?
+	FILE* cpuinfo = LLFile::fopen(CPUINFO_FILE, "r");		/* Flawfinder: ignore */
+	if(cpuinfo)
+	{
+		char line[MAX_STRING];		/* Flawfinder: ignore */
+		memset(line, 0, MAX_STRING);
+		while(fgets(line, MAX_STRING, cpuinfo))
+		{
+			// /proc/cpuinfo on Linux looks like:
+			// name\t*: value\n
+			char* tabspot = strchr( line, '\t' );
+			if (tabspot == NULL)
+				continue;
+			char* colspot = strchr( tabspot, ':' );
+			if (colspot == NULL)
+				continue;
+			char* nlspot = strchr( line, '\n' );
+			if (nlspot == NULL)
+				nlspot = line + strlen( line );	// Fallback to terminating NULL
+
+			std::string linename( line, tabspot );
+			std::string lineval( colspot + 2, nlspot );
+			mCPUInfoLines[ linename ] = lineval;
+		}
+		fclose(cpuinfo);
+	}
+#endif
 }
 
 
 std::string LLCPUInfo::getCPUString() const
 {
-#if LL_WINDOWS || LL_DARWIN
 	std::ostringstream out;
 
+#if LL_WINDOWS || LL_DARWIN
 	CProcessor proc;
 	(void) proc.GetCPUInfo();
 	out << proc.strCPUName << " ";
@@ -328,10 +356,30 @@
 		out << "(" << (S32)(freq) << " MHz)";
 	}
 
-	return out.str();
+#else // LL_LINUX
+#if ( defined(__i386__) || defined(__amd64__) )
+	out << getInfoLine( "model name" );
+#elif defined(__powerpc__)
+	out << getInfoLine( "platform" ) << " (" << getInfoLine( "clock" ) << ")";
 #else
-	return "Can't get terse CPU information";
+	out << "Can't get terse CPU information";
+#endif
 #endif
+	return out.str();
+}
+
+const std::string& LLCPUInfo::getInfoLine( const std::string index ) const
+{
+	std::map< std::string, std::string >::const_iterator data = mCPUInfoLines.find( index );
+	if (data != mCPUInfoLines.end())
+	{
+		return (*data).second;
+	}
+	else
+	{
+		static const std::string empty;
+		return empty;
+	}
 }
 
 void LLCPUInfo::stream(std::ostream& s) const
@@ -349,22 +397,16 @@
 		s << "Unable to collect processor info";
 	}
 #else
-	// *NOTE: This works on linux. What will it do on other systems?
-	FILE* cpuinfo = LLFile::fopen(CPUINFO_FILE, "r");		/* Flawfinder: ignore */
-	if(cpuinfo)
+	// Return the machine information we gathered in the constructor
+	if(!mCPUInfoLines.empty())
 	{
-		char line[MAX_STRING];		/* Flawfinder: ignore */
-		memset(line, 0, MAX_STRING);
-		while(fgets(line, MAX_STRING, cpuinfo))
-		{
-			line[strlen(line)-1] = ' ';		 /*Flawfinder: ignore*/
-			s << line;
-		}
-		fclose(cpuinfo);
+		for( std::map< std::string, std::string >::const_iterator i = mCPUInfoLines.begin();
+				i != mCPUInfoLines.end(); ++i )
+			s << (*i).first << "\t: " << (*i).second << ' ';
 	}
 	else
 	{
-		s << "Unable to collect memory information";
+		s << "Unable to collect processor information";
 	}
 #endif
 }
diff -urNad linden~/indra/llcommon/llsys.h linden/indra/llcommon/llsys.h
--- linden~/indra/llcommon/llsys.h	2007-05-06 03:14:25.000000000 +1000
+++ linden/indra/llcommon/llsys.h	2007-05-06 03:18:31.000000000 +1000
@@ -40,6 +40,7 @@
 
 #include <iosfwd>
 #include <string>
+#include <map>
 
 class LLOSInfo
 {
@@ -79,11 +80,18 @@
 	// Family is "AMD Duron" or "Intel Pentium Pro"
 	const std::string& getFamily() const { return mFamily; }
 
+#ifdef LL_LINUX
+	const std::string& getInfoLine( const std::string index ) const;
+#endif
+
 private:
 	BOOL mHasSSE;
 	BOOL mHasSSE2;
 	S32 mCPUMhz;
 	std::string mFamily;
+#ifdef LL_LINUX
+	std::map< std::string, std::string > mCPUInfoLines;
+#endif
 };
 
 class LLMemoryInfo
