Index: src/audio/audio_rx.cpp
===================================================================
--- src/audio/audio_rx.cpp	(revision 290)
+++ src/audio/audio_rx.cpp	(working copy)
@@ -18,9 +18,12 @@
 
 #include <iostream>
 #include <cstdio>
+#include <ctime>
+#include <cstdlib>
 #include <sys/types.h>
 #include <sys/time.h>
 #include <cc++/config.h>
+
 #include "audio_rx.h"
 #include "log.h"
 #include "phone.h"
@@ -28,8 +31,7 @@
 #include "userintf.h"
 #include "line.h"
 #include "sys_settings.h"
-#include <ctime>
-#include <cstdlib>
+#include "sequence_number.h"
 #include "audits/memman.h"
 
 extern t_phone *phone;
@@ -79,7 +81,12 @@
 			nanosleep(&sleeptimer, NULL);
 			return false;
 		}
+		
+		mtx_3way.unlock();
 	} else {
+		// Don't keep the 3way mutex locked while waiting for the DSP.
+		mtx_3way.unlock();
+		
 		// Get the sound samples from the DSP
 		status = input_device->read(sample_buf, SAMPLE_BUF_SIZE);
 		if (status != SAMPLE_BUF_SIZE) {
@@ -97,7 +104,6 @@
 				logged_capture_failure = true;
 			}
 			stop_running = true;
-			mtx_3way.unlock();
 			return false;
 		}
 
@@ -117,6 +123,7 @@
 		pcm_reduce_noise(sb, SAMPLE_BUF_SIZE / 2);
 	}
 
+	mtx_3way.lock();
 	if (is_3way) {
 		// Send the sound samples to the other receiver if we
 		// are the main receiver.
@@ -480,7 +487,8 @@
 		// the timestamp. This will happen if the DSP delivers more
 		// sound samples than the set sample rate. To compensate for this
 		// samples must be dropped.
-		if (timestamp <= rtp_session->getCurrentTimestamp() + nsamples) {
+		uint32 current_timestamp = rtp_session->getCurrentTimestamp();
+		if (seq32_t(timestamp) <= seq32_t(current_timestamp + nsamples)) {
 			if (dtmf_player) {
 				// Send DTMF payload
 				rtp_session->putData(dtmf_rtp_timestamp, payload,
@@ -507,6 +515,15 @@
 			log_file->write_raw("Audio rx line ");
 			log_file->write_raw(get_line()->get_line_number()+1);
 			log_file->write_raw(": discarded surplus of sound samples.\n");
+			log_file->write_raw("Timestamp: ");
+			log_file->write_raw(timestamp);
+			log_file->write_endl();
+			log_file->write_raw("Current timestamp: ");
+			log_file->write_raw(current_timestamp);
+			log_file->write_endl();
+			log_file->write_raw("nsamples: ");
+			log_file->write_raw(nsamples);
+			log_file->write_endl();
 			log_file->write_footer();
 		}
 
@@ -528,8 +545,9 @@
 		// stack. It might get behind if the sound cards samples a bit
 		// slower than the set sample rate. Advance the timestamp to get
 		// in sync again.
-		if (timestamp <= rtp_session->getCurrentTimestamp() - 
-			(JITTER_BUF_MS / audio_encoder->get_ptime()) * nsamples)
+		current_timestamp = rtp_session->getCurrentTimestamp();
+		if (seq32_t(timestamp) <= seq32_t(current_timestamp - 
+			(JITTER_BUF_MS / audio_encoder->get_ptime()) * nsamples))
 		{
 			timestamp += nsamples * (JITTER_BUF_MS / audio_encoder->get_ptime());
 			log_file->write_header("t_audio_rx::run", LOG_NORMAL, LOG_DEBUG);
@@ -539,6 +557,15 @@
 			log_file->write_raw(nsamples * (JITTER_BUF_MS /
 					audio_encoder->get_ptime()));
 			log_file->write_endl();
+			log_file->write_raw("Timestamp: ");
+			log_file->write_raw(timestamp);
+			log_file->write_endl();
+			log_file->write_raw("Current timestamp: ");
+			log_file->write_raw(current_timestamp);
+			log_file->write_endl();
+			log_file->write_raw("nsamples: ");
+			log_file->write_raw(nsamples);
+			log_file->write_endl();
 			log_file->write_footer();
 		}			
 	}
Index: src/audio/audio_tx.cpp
===================================================================
--- src/audio/audio_tx.cpp	(revision 298)
+++ src/audio/audio_tx.cpp	(working copy)
@@ -27,6 +27,7 @@
 #include "phone.h"
 #include "userintf.h"
 #include "line.h"
+#include "sequence_number.h"
 #include "audits/memman.h"
 
 extern t_phone *phone;
@@ -638,11 +639,11 @@
 		// This must be done before decoding the received samples as the
 		// speex decoder has its own PLC algorithm for which it needs the decoding
 		// state before decoding the new samples.
-		if (adu->getSeqNum() != (last_seqnum + 1) % 65536 && last_seqnum != -1) {
+		seq16_t seq_recvd(adu->getSeqNum());
+		seq16_t seq_last(static_cast<uint16>(last_seqnum));
+		if (last_seqnum != -1 && seq_recvd - seq_last > 1) {
 			// Packets have been lost
-			int num_lost = adu->getSeqNum() - last_seqnum - 1;
-			if (num_lost < 0) num_lost += 65536; // seqnum wrapped around
-
+			uint16 num_lost = (seq_recvd - seq_last) - 1;
 			log_file->write_header("t_audio_tx::run", LOG_NORMAL, LOG_DEBUG);
 			log_file->write_raw("Audio tx line ");
 			log_file->write_raw(get_line()->get_line_number()+1);
Index: src/audio/media_buffer.cpp
===================================================================
--- src/audio/media_buffer.cpp	(revision 283)
+++ src/audio/media_buffer.cpp	(working copy)
@@ -49,6 +49,7 @@
 		return;
 	}
 
+	int current_size_content = size_content();
 	if (empty) {
 		data_start = 0;
 		data_end = len - 1;
@@ -71,7 +72,7 @@
 	// Check if the new data wrapped over the start of the old data.
 	// If so, then advance the start of the old data behind the end of the new
 	// data as new data has erased the oldest data.
-	if (buf_size - size_content() < len) {
+	if (buf_size - current_size_content < len) {
 		pos_start =  (data_end + 1) % buf_size;
 	}
 
--- src/sequence_number.h	(revision 0)
+++ src/sequence_number.h	(revision 0)
@@ -0,0 +1,82 @@
+/*
+    Copyright (C) 2005-2007  Michel de Boer <michel@twinklephone.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef _SEQUENCE_NUMBER_H
+#define _SEQUENCE_NUMBER_H
+
+#include <cc++/config.h>
+
+/**
+ * Sequence numbers.
+ * Sequence numbers with comparison operators that deal with sequence number
+ * wrap arounds using serial number arithmetic.
+ * See http://en.wikipedia.org/wiki/Serial_Number_Arithmetic
+ *
+ * @param U the unsigned int type for the sequence number.
+ * @param S the corresponsing signed int type.
+ */
+template< typename U, typename S >
+class sequence_number_t {
+private:
+	U _number;
+
+public:
+	explicit sequence_number_t(U number) : _number(number)
+	{};
+
+	U get_number(void) const {
+		return _number;
+	}
+
+	operator U(void) const {
+		return get_number();
+	}
+
+	S distance(const sequence_number_t &number) const {
+		return static_cast<S>(_number - number.get_number());
+	}
+
+	S operator-(const sequence_number_t &number) const {
+		return distance(number);
+	}
+
+	bool operator<(const sequence_number_t &number) const {
+		return (distance(number) < 0);
+	}
+
+	bool operator<=(const sequence_number_t &number) const {
+		return (distance(number) <= 0);
+	}
+
+	bool operator==(const sequence_number_t &number) const {
+		return (number.get_number() == _number);
+	}
+
+	bool operator>(const sequence_number_t &number) const {
+		return (distance(number) > 0);
+	}
+
+	bool operator>=(const sequence_number_t &number) const {
+		return (distance(number) >= 0);
+	}
+};
+
+typedef sequence_number_t<uint16, int16> seq16_t;
+typedef sequence_number_t<uint32, int32> seq32_t;
+
+#endif
Index: src/Makefile.am
===================================================================
--- src/Makefile.am	(revision 283)
+++ src/Makefile.am	(working copy)
@@ -75,6 +75,7 @@
 	protocol.h\
         redirect.h\
         sender.h\
+	sequence_number.h\
         service.h\
         session.h\
 	sub_refer.h\
