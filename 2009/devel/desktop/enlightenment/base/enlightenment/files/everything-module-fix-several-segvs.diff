Index: e/src/modules/everything/evry_plug_apps.c
===================================================================
--- e/src/modules/everything/evry_plug_apps.c	(revision 41007)
+++ e/src/modules/everything/evry_plug_apps.c	(revision 41162)
@@ -1,126 +1,300 @@
 #include "e.h"
 #include "e_mod_main.h"
 
-static Eina_Hash *added = NULL;
-static Evry_Plugin plugin;
+typedef struct _Inst Inst;
 
-static int  _evry_plug_apps_fetch(char *string);
-static int  _evry_plug_apps_action(Evry_Item *item);
-static void _evry_plug_apps_cleanup(void);
-static void _evry_plug_apps_item_add(Efreet_Desktop *desktop, char *file, int prio);
-static int  _evry_plug_apps_cb_sort(const void *data1, const void *data2);
-static void _evry_plug_apps_item_icon_get(Evry_Item *it, Evas *e);
+struct _Inst
+{
+  Eina_Hash *added;
 
+  Eina_List *apps;
+  Evry_Item *candidate;
+};
 
+static Evry_Plugin *_plug_new();
+static Evry_Plugin *_plug_new2();
+static void _plug_free(Evry_Plugin *p);
+static int  _begin(Evry_Plugin *p, Evry_Item *item);
+static int  _fetch(Evry_Plugin *p, const char *input);
+static int  _action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _cleanup(Evry_Plugin *p);
+static void _item_add(Evry_Plugin *p, Efreet_Desktop *desktop, char *file, int prio);
+static int  _cb_sort(const void *data1, const void *data2);
+static void _item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+
+static Evry_Plugin_Class class;
+static Evry_Plugin_Class class2;
+
 EAPI int
 evry_plug_apps_init(void)
 {
-   plugin.name = "Applications";
-   plugin.type = "APPLICATION";
-   plugin.need_query = 0;
-   plugin.fetch  = &_evry_plug_apps_fetch;
-   plugin.action = &_evry_plug_apps_action;
-   plugin.cleanup = &_evry_plug_apps_cleanup;
-   plugin.icon_get = &_evry_plug_apps_item_icon_get;
-   plugin.candidates = NULL;   
+   class.name = "Applications";
+   class.type_in  = "NONE";
+   class.type_out = "APPLICATION";
+   class.need_query = 0;
+   class.new = &_plug_new;
+   class.free = &_plug_free;
+   class.prio = 1;
+   evry_plugin_register(&class);
 
-   evry_plugin_add(&plugin);
-   
+   class2.name = "Open With..";
+   class2.type_in  = "FILE";
+   class2.type_out = "APPLICATION";
+   class2.need_query = 0;
+   class2.new = &_plug_new2;
+   class2.free = &_plug_free;
+   class2.prio = 3;
+   evry_plugin_register(&class2);
+
    return 1;
 }
 
 EAPI int
 evry_plug_apps_shutdown(void)
 {
-   evry_plugin_remove(&plugin);
+   evry_plugin_unregister(&class);
+   evry_plugin_unregister(&class2);
    
    return 1;
 }
 
+static Evry_Plugin *
+_plug_new()
+{
+   Evry_Plugin *p = E_NEW(Evry_Plugin, 1);
+   p->class = &class;
+   p->fetch = &_fetch;
+   p->action = &_action;
+   p->cleanup = &_cleanup;
+   p->icon_get = &_item_icon_get;
+   p->items = NULL;   
+
+   Inst *inst = E_NEW(Inst, 1);
+   inst->added = NULL;
+   p->priv = inst;
+
+   return p;
+}
+
+static Evry_Plugin *
+_plug_new2()
+{
+   Evry_Plugin *p = E_NEW(Evry_Plugin, 1);
+   p->class = &class2;
+   p->begin = &_begin;
+   p->fetch = &_fetch;
+   p->action = &_action;
+   p->cleanup = &_cleanup;
+   p->icon_get = &_item_icon_get;
+   p->items = NULL;   
+
+   Inst *inst = E_NEW(Inst, 1);
+   inst->added = NULL;
+   p->priv = inst;
+
+   return p;
+}
+
+static void
+_plug_free(Evry_Plugin *p)
+{
+   Inst *inst = p->priv;
+   
+   _cleanup(p);
+   if (inst->apps) eina_list_free(inst->apps);
+   
+   E_FREE(inst);
+   E_FREE(p);
+}
+
 static int
-_evry_plug_apps_action(Evry_Item *item)
+_begin(Evry_Plugin *p, Evry_Item *it)
 {
-   E_Zone *zone;
-   Evry_App *app;
+   Inst *inst;
+   const char *mime;
+   
+   _cleanup(p);
 
-   app = item->data;
-   zone = e_util_zone_current_get(e_manager_current_get());
-
-   if (app->desktop)
-     e_exec(zone, app->desktop, NULL, NULL, "everything");
+   if (!it || !it->uri) return 0;
+   inst = p->priv;
+   inst->candidate = it;
+   
+   if (!it->mime)
+     mime = efreet_mime_type_get(it->uri);
    else
-     e_exec(zone, NULL, app->file, NULL, "everything");
+     mime = it->mime;
+   
+   if (!mime) return 0;
 
+   /* if (!strcmp(mime, "Folder"))
+    *   {
+    * 	apps = 
+    *   }
+    * else */
+
+   inst->apps = efreet_util_desktop_mime_list(mime);
+   
    return 1;
 }
 
+
+static int
+_action(Evry_Plugin *p, Evry_Item *it, const char *input)
+{
+   E_Zone *zone;
+   Evry_App *app = NULL;
+   Efreet_Desktop *desktop = NULL; 
+   Eina_List *files = NULL;
+   Inst *inst = p->priv;
+   int ret = 0;
+
+   if (it) app = it->data[0];
+   
+   if (inst->candidate)
+     files = eina_list_append(files, inst->candidate->uri);
+   
+   if (app && app->desktop)
+     {
+	desktop = app->desktop;
+     }
+   else
+     {
+	if (app && app->file)
+	  input = app->file;
+	
+	desktop = efreet_desktop_empty_new("");
+	if (strchr(input, '%'))
+	  {
+	     desktop->exec = strdup(input);
+	  }
+	else
+	  {
+	     int len = strlen(input) + 4;
+	     desktop->exec = malloc(len);
+	     if (desktop->exec)
+	       snprintf(desktop->exec, len, "%s %%U", input);
+	  }
+     }
+
+   if (desktop)
+     {
+	zone = e_util_zone_current_get(e_manager_current_get());
+	e_exec(zone, desktop, NULL, files, NULL /*"everything"*/);
+
+	if (!it)
+	  efreet_desktop_free(desktop);
+	
+	ret = 1;
+     }
+   
+   eina_list_free(files);
+   
+   return ret;
+}
+
 static void
-_evry_plug_apps_cleanup(void)
+_cleanup(Evry_Plugin *p)
 {
    Evry_Item *it;
    Evry_App *app;
    
-   EINA_LIST_FREE(plugin.candidates, it)
+   EINA_LIST_FREE(p->items, it)
      {
 	if (it->label) eina_stringshare_del(it->label);
 	if (it->o_icon) evas_object_del(it->o_icon);
-	app = it->data;
+	app = it->data[0];
 	free(app);
 	free(it);
      }
 }
 
 static int
-_evry_plug_apps_fetch(char *string)
+_fetch(Evry_Plugin *p, const char *input)
 {
-   char buf[4096];
-   Eina_List *list;
+   Eina_List *l;
    Efreet_Desktop *desktop;
    char *file;
+   char match1[4096];
+   char match2[4096];
    
-   _evry_plug_apps_cleanup(); 
+   Inst *inst = p->priv;
+   
+   _cleanup(p); 
 
-   if (string)
+   if (inst->apps)
      {
-	snprintf(buf, sizeof(buf), "%s*", string);
-	list = efreet_util_desktop_exec_glob_list(buf);
-	EINA_LIST_FREE(list, desktop)
-	  _evry_plug_apps_item_add(desktop, NULL, 1);
+	if (!input)
+	  {
+	     EINA_LIST_FOREACH(inst->apps, l, desktop)
+	       _item_add(p, desktop, NULL, 1);
+	  }
+	else
+	  {
+	     snprintf(match1, sizeof(match1), "%s*", input);
+	     snprintf(match2, sizeof(match2), "*%s*", input);
+
+	     EINA_LIST_FOREACH(inst->apps, l, desktop)
+	       {
+		  if (desktop->name)
+		    {		  
+		       if (e_util_glob_case_match(desktop->name, match1))
+			 _item_add(p, desktop, NULL, 1);
+		       else if (e_util_glob_case_match(desktop->name, match2))
+			 _item_add(p, desktop, NULL, 2);
+		       else if (desktop->comment)
+			 {
+			    if (e_util_glob_case_match(desktop->comment, match1))
+			      _item_add(p, desktop, NULL, 3);
+			    else if (e_util_glob_case_match(desktop->comment, match2))
+			      _item_add(p, desktop, NULL, 4);
+			 }
+		    }
+	       }
+	  }
+     }
    
-	snprintf(buf, sizeof(buf), "*%s*", string);
-	list = efreet_util_desktop_name_glob_list(buf);
-	EINA_LIST_FREE(list, desktop)
-	  _evry_plug_apps_item_add(desktop, NULL, 2); 
+   
+   if (!p->items && input)
+     {
+	snprintf(match1, sizeof(match1), "%s*", input);
+	l = efreet_util_desktop_exec_glob_list(match1);
+	EINA_LIST_FREE(l, desktop)
+	  _item_add(p, desktop, NULL, 1);
+   
+	snprintf(match1, sizeof(match1), "*%s*", input);
+	l = efreet_util_desktop_name_glob_list(match1);
+	EINA_LIST_FREE(l, desktop)
+	  _item_add(p, desktop, NULL, 2); 
 
 	// TODO make these optional/configurable
-	snprintf(buf, sizeof(buf), "*%s*", string);
-	list = efreet_util_desktop_generic_name_glob_list(buf);
-	EINA_LIST_FREE(list, desktop)
-	  _evry_plug_apps_item_add(desktop, NULL, 3); 
+	l = efreet_util_desktop_generic_name_glob_list(match1);
+	EINA_LIST_FREE(l, desktop)
+	  _item_add(p, desktop, NULL, 3); 
 
-	snprintf(buf, sizeof(buf), "*%s*", string);
-	list = efreet_util_desktop_comment_glob_list(buf);
-	EINA_LIST_FREE(list, desktop)
-	  _evry_plug_apps_item_add(desktop, NULL, 3);
+	l = efreet_util_desktop_comment_glob_list(match1);
+	EINA_LIST_FREE(l, desktop)
+	  _item_add(p, desktop, NULL, 3);
      }
-   else
+   else if (!p->items)
      {
 	// TODO option for popular/recent
-	list = e_exehist_list_get();
-	EINA_LIST_FREE(list, file)
-	  _evry_plug_apps_item_add(NULL, file, 1);
+	l = e_exehist_list_get();
+	EINA_LIST_FREE(l, file)
+	  _item_add(p, NULL, file, 1);
      }
    
-   if (added)
+   if (inst->added)
      {
-	eina_hash_free(added);
-	added = NULL;
-
-	if (string)
-	  plugin.candidates =
-	    eina_list_sort(plugin.candidates,
-			   eina_list_count(plugin.candidates),
-			   _evry_plug_apps_cb_sort);
+	eina_hash_free(inst->added);
+	inst->added = NULL;
+     }
+   
+   if (p->items)
+     {
+	if (input)
+	  p->items = eina_list_sort(p->items,
+			   eina_list_count(p->items),
+			   _cb_sort);
 	return 1;
      }
     
@@ -128,43 +302,69 @@
 }
 
 static void
-_evry_plug_apps_item_add(Efreet_Desktop *desktop, char *file, int prio)
+_item_add(Evry_Plugin *p, Efreet_Desktop *desktop, char *file, int prio)
 {
    Evry_Item *it;
    Evry_App *app;
+   Inst *inst = p->priv;
+   Efreet_Desktop *desktop2;
 
    if (desktop)
-     file = ecore_file_app_exe_get(desktop->exec);
+     file = desktop->exec;
 
    if (!file) return;
-   
-   if (eina_hash_find(added, file))
-     {
-	if (desktop) free(file);
+
+   if (!inst->added)
+     inst->added = eina_hash_string_superfast_new(NULL);
+
+
+   if (!desktop)
+   {
+      char match[4096];
+      Eina_List *l;
+      int len;
+      char *tmp;
+      int found = 0;
+	
+      if (eina_hash_find(inst->added, file))
 	return;
-     }
-   
-   if (!added)
-     added = eina_hash_string_superfast_new(NULL);
 
-   eina_hash_add(added, file, file);
+      len = strlen(file);
+      tmp = ecore_file_app_exe_get(file);
+      snprintf(match, sizeof(match), "%s*", tmp);	
+      l = efreet_util_desktop_exec_glob_list(match);
 
+      EINA_LIST_FREE(l, desktop)
+	{
+	   if (desktop->exec && !strncmp(file, desktop->exec, len))
+	     {
+		found = 1;
+		break;
+	     }
+	}
+
+      eina_list_free(l);
+      free(tmp);
+
+      if (!found)
+	eina_hash_add(inst->added, file, file);
+   }
+
    if (desktop)
      {
-	free(file);
+	if ((desktop2 = eina_hash_find(inst->added, file)))
+	  if (desktop == desktop2)
+	    return;
+
+	eina_hash_add(inst->added, file, desktop);
 	file = NULL;
      }
-   else 
-     {
-	desktop = efreet_util_desktop_exec_find(file);
-	if (desktop) file = NULL;
-     }
    
    it = calloc(1, sizeof(Evry_Item));
    app = calloc(1, sizeof(Evry_App));
    app->desktop = desktop;
    app->file = file;
-   it->data = app;
+   it->data[0] = app;
    it->priority = prio;
    if (desktop)
      it->label = eina_stringshare_add(desktop->name);
@@ -172,20 +372,27 @@
      it->label = eina_stringshare_add(file);
    it->o_icon = NULL;
 
-   plugin.candidates = eina_list_append(plugin.candidates, it);
+   p->items = eina_list_append(p->items, it);
 }
 
 static void
-_evry_plug_apps_item_icon_get(Evry_Item *it, Evas *e)
+_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
 {
-   Evry_App *app = it->data;
+   Evry_App *app = it->data[0];
    
    if (app->desktop)
      it->o_icon = e_util_desktop_icon_add(app->desktop, 24, e);
+
+   if (!it->o_icon)
+     {
+	it->o_icon = edje_object_add(e);
+	/* e_util_icon_theme_set(it->o_icon, "system-run") */
+	e_theme_edje_object_set(it->o_icon, "base/theme/fileman", "e/icons/system-run");
+     }
 }
 
 static int
-_evry_plug_apps_cb_sort(const void *data1, const void *data2)
+_cb_sort(const void *data1, const void *data2)
 {
    const Evry_Item *it1, *it2;
    Evry_App *app1, *app2;
@@ -194,8 +401,8 @@
    
    it1 = data1;
    it2 = data2;
-   app1 = it1->data;
-   app2 = it2->data;
+   app1 = it1->data[0];
+   app2 = it2->data[0];
    e1 = efreet_util_path_to_file_id(app1->desktop->orig_path);
    e2 = efreet_util_path_to_file_id(app2->desktop->orig_path);
    t1 = e_exehist_newest_run_get(e1);
Index: e/src/modules/everything/evry_plug_config.c
===================================================================
--- e/src/modules/everything/evry_plug_config.c	(revision 41007)
+++ e/src/modules/everything/evry_plug_config.c	(revision 41162)
@@ -1,39 +1,59 @@
 #include "e.h"
 #include "e_mod_main.h"
 
-static Evry_Plugin plugin;
+static Evry_Plugin_Class class;
+static Evry_Plugin *_plug_new();
+static void  _plug_free(Evry_Plugin *p);
+static int  _fetch(Evry_Plugin *p, const char *input);
+static int  _action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _cleanup(Evry_Plugin *p);
+static void _item_add(Evry_Plugin *p, E_Configure_It *eci, int prio);
+static void _item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+static int  _cb_sort(const void *data1, const void *data2);
 
-static int  _evry_plug_config_fetch(char *string);
-static int  _evry_plug_config_action(Evry_Item *item);
-static void _evry_plug_config_cleanup(void);
-static void _evry_plug_config_item_add(E_Configure_It *eci, int prio);
-static int  _evry_plug_config_cb_sort(const void *data1, const void *data2);
-static void _evry_plug_config_item_icon_get(Evry_Item *it, Evas *e);
-
 EAPI int
 evry_plug_config_init(void)
 {
-   plugin.name = "Settings";
-   plugin.fetch  = &_evry_plug_config_fetch;
-   plugin.action = &_evry_plug_config_action;
-   plugin.cleanup = &_evry_plug_config_cleanup;
-   plugin.icon_get = &_evry_plug_config_item_icon_get;
-   plugin.candidates = NULL;   
-   evry_plugin_add(&plugin);
-   
+   class.name = "Settings";
+   class.type_in  = "NONE";
+   class.type_out = "NONE";
+   class.instances = NULL;
+   class.new = &_plug_new;
+   class.free = &_plug_free;
+   evry_plugin_register(&class);
    return 1;
 }
 
 EAPI int
 evry_plug_config_shutdown(void)
 {
-   evry_plugin_remove(&plugin);
+   evry_plugin_unregister(&class);
    
    return 1;
 }
 
+static Evry_Plugin *
+_plug_new()
+{
+   Evry_Plugin *p = E_NEW(Evry_Plugin, 1);
+   p->class = &class;
+   p->fetch = &_fetch;
+   p->action = &_action;
+   p->cleanup = &_cleanup;
+   p->icon_get = &_item_icon_get;
+   p->items = NULL;   
+}
+
+
+static void
+_plug_free(Evry_Plugin *p)
+{
+   _cleanup(p);
+   E_FREE(p);
+}
+
 static int
-_evry_plug_config_action(Evry_Item *item)
+_action(Evry_Plugin *p, Evry_Item *it, const char *input)
 {
    E_Configure_It *eci, *eci2;
    E_Container *con;
@@ -41,14 +61,16 @@
    Eina_List *l, *ll;
    char buf[1024];
    int found = 0;
+
+   if (!it) return 0;
    
-   eci = item->data;
+   eci = it->data[0];
    con = e_container_current_get(e_manager_current_get());
 
-   for (l = e_configure_registry; l; l = l->next)
+   for (l = e_configure_registry; l && !found; l = l->next)
      {
 	ecat = l->data;
-	for (ll = ecat->items; ll; ll = ll->next)
+	for (ll = ecat->items; ll && !found; ll = ll->next)
 	  {
 	     eci2 = ll->data;
 	     if (eci == eci2)
@@ -68,13 +90,12 @@
 }
 
 static void
-_evry_plug_config_cleanup(void)
+_cleanup(Evry_Plugin *p)
 {
    Evry_Item *it;
 
-   EINA_LIST_FREE(plugin.candidates, it)
+   EINA_LIST_FREE(p->items, it)
      {
-	/* if (it->data)  */
 	if (it->label) eina_stringshare_del(it->label);
 	if (it->o_icon) evas_object_del(it->o_icon);
 	free(it);
@@ -82,7 +103,7 @@
 }
 
 static int
-_evry_plug_config_fetch(char *string)
+_fetch(Evry_Plugin *p, const char *input)
 {
    E_Manager *man;
    E_Zone *zone;
@@ -93,10 +114,10 @@
    E_Configure_Cat *ecat;
    E_Configure_It *eci;
    
-   _evry_plug_config_cleanup(); 
+   _cleanup(p); 
 
-   snprintf(match1, sizeof(match1), "%s*", string);
-   snprintf(match2, sizeof(match2), "*%s*", string);
+   snprintf(match1, sizeof(match1), "%s*", input);
+   snprintf(match2, sizeof(match2), "*%s*", input);
 
    for (l = e_configure_registry; l; l = l->next)
      {
@@ -109,24 +130,23 @@
 		  if (eci->pri >= 0)
 		    {
 		       if (e_util_glob_case_match(eci->label, match1))
-			 _evry_plug_config_item_add(eci, 1);
+			 _item_add(p, eci, 1);
 		       else if (e_util_glob_case_match(eci->label, match2))
-			 _evry_plug_config_item_add(eci, 2);
+			 _item_add(p, eci, 2);
 		       else if (e_util_glob_case_match(ecat->label, match1))
-			 _evry_plug_config_item_add(eci, 3);
+			 _item_add(p, eci, 3);
 		       else if (e_util_glob_case_match(ecat->label, match2))
-			 _evry_plug_config_item_add(eci, 4);
+			 _item_add(p, eci, 4);
 		    }
 	       }
 	  }
      }
    
-   if (eina_list_count(plugin.candidates) > 0)
+   if (eina_list_count(p->items) > 0)
      {
-	plugin.candidates =
-	  eina_list_sort(plugin.candidates,
-			 eina_list_count(plugin.candidates),
-			 _evry_plug_config_cb_sort);
+	p->items = eina_list_sort(p->items, 
+				       eina_list_count(p->items),
+				       _cb_sort);
 	return 1;
      }
 
@@ -134,9 +154,9 @@
 }
 
 static void
-_evry_plug_config_item_icon_get(Evry_Item *it, Evas *e)
+_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
 {
-   E_Configure_It *eci = it->data;
+   E_Configure_It *eci = it->data[0];
    Evas_Object *o = NULL;
    
    if (eci->icon) 
@@ -153,23 +173,23 @@
 }
 
 static void
-_evry_plug_config_item_add(E_Configure_It *eci, int prio)
+_item_add(Evry_Plugin *p, E_Configure_It *eci, int prio)
 {
    Evry_Item *it;   
 
    it = calloc(1, sizeof(Evry_Item));
-   it->data = eci;
+   it->data[0] = eci;
    it->priority = prio;
    it->label = eina_stringshare_add(eci->label);
    it->o_icon = NULL; 
 	     
-   plugin.candidates = eina_list_append(plugin.candidates, it);
+   p->items = eina_list_append(p->items, it);
 }
 
 
 // TODO sort name?
 static int
-_evry_plug_config_cb_sort(const void *data1, const void *data2)
+_cb_sort(const void *data1, const void *data2)
 {
    const Evry_Item *it1, *it2;
    
Index: e/src/modules/everything/evry.c
===================================================================
--- e/src/modules/everything/evry.c	(revision 41007)
+++ e/src/modules/everything/evry.c	(revision 41162)
@@ -5,6 +5,22 @@
 #define INPUTLEN 40
 #define MATCH_LAG 0.33
 
+
+typedef struct _Evry_State Evry_State;
+
+struct _Evry_State
+{
+  Eina_List *cur_plugins;
+  Eina_List *plugins;
+  Evry_Plugin *cur_plugin;
+  Evry_Item *sel_item;
+  /* Eina_List *sel_items; */
+  char *input;
+
+  Eina_Bool initial;
+  Eina_Bool get_parameter; /* TODO better name !*/
+};
+
 static int  _evry_cb_key_down(void *data, int type, void *event);
 static int  _evry_cb_key_down(void *data, int type, void *event);
 static int  _evry_cb_mouse_down(void *data, int type, void *event);
@@ -15,9 +31,8 @@
 static void _evry_cb_item_mouse_out(void *data, Evas *evas, Evas_Object *obj, void *event_info);
 static void _evry_backspace(void);
 static void _evry_update(void);
-static void _evry_matches_clear(void);
 static void _evry_list_clear(void);
-static void _evry_show_candidates(Evry_Plugin *plugin);
+static void _evry_show_items(Evry_Plugin *plugin);
 static int  _evry_update_timer(void *data);
 static void _evry_matches_update(void);
 static void _evry_clear(void);
@@ -28,11 +43,15 @@
 static void _evry_scroll_to(int i);
 static void _evry_item_desel(Evry_Item *it);
 static void _evry_item_sel(Evry_Item *it);
-static void _evry_item_remove(Evry_Item *it);
 static void _evry_action(int finished);
+static void _evry_action_select(void);
 static void _evry_cb_plugin_sel(void *data1, void *data2);
 static int  _evry_animator(void *data);
 static int  _evry_scroll_timer(void *data);
+static int  _evry_push_state(void);
+static int  _evry_pop_state(void);
+static void _evry_plugin_selector_append(Evry_Plugin *p);
+static int _evry_cb_plugin_sort(const void *data1, const void *data2);
 
 
 /* local subsystem globals */
@@ -40,17 +59,16 @@
 static Ecore_X_Window input_window = 0;
 static Evas_Object *o_list = NULL;
 static Evas_Object *o_main = NULL;
-static Evas_Object *icon_object = NULL;
-static Evas_Object *o_toolbar = NULL;
-static char        *cmd_buf = NULL;
+static Evas_Object *o_selector = NULL;
+static Evas_Object *o_selector_frame = NULL;
 static Eina_List   *handlers = NULL;
 static Ecore_Timer *update_timer = NULL;
 
-static Eina_List   *sources = NULL;
-static Eina_List   *cur_sources = NULL;
-static Evry_Plugin *cur_source;
+static Eina_List   *plugins = NULL;
+static Evry_State  *cur_state = NULL;
+static Eina_List   *stack = NULL;
 
-static Evry_Item   *item_selected = NULL;
+static int ev_last_is_mouse;
 static Evry_Item   *item_mouseover = NULL;
 
 static Ecore_Animator *scroll_animator = NULL;
@@ -58,9 +76,7 @@
 static double       scroll_align_to;
 static double       scroll_align;
 
-static int ev_last_is_mouse;
 
-
 /* externally accessible functions */
 EAPI int
 evry_init(void)
@@ -76,16 +92,16 @@
 }
 
 EAPI void
-evry_plugin_add(Evry_Plugin *plugin)
+evry_plugin_register(Evry_Plugin_Class *plugin)
 {
-   sources = eina_list_append(sources, plugin);
+   plugins = eina_list_append(plugins, plugin);
    /* TODO sorting, initialization, etc */
 }
 
 EAPI void
-evry_plugin_remove(Evry_Plugin *plugin)
+evry_plugin_unregister(Evry_Plugin_Class *plugin)
 {
-   sources = eina_list_remove(sources, plugin);
+   plugins = eina_list_remove(plugins, plugin);
    /* cleanup */
 }
 
@@ -116,16 +132,7 @@
    popup = e_popup_new(zone, x, y, evry_conf->width, evry_conf->height);
    if (!popup) return 0;
 
-   cmd_buf = malloc(INPUTLEN);
-   if (!cmd_buf)
-     {
-	e_object_del(E_OBJECT(popup));
-	return 0;
-     }
-
    ecore_x_netwm_window_type_set(popup->evas_win, ECORE_X_WINDOW_TYPE_UTILITY);
-
-   cmd_buf[0] = 0;
    
    e_popup_layer_set(popup, 255);
    evas_event_freeze(popup->evas);
@@ -135,7 +142,6 @@
    o_main = o;
    e_theme_edje_object_set(o, "base/theme/everything",
 			   "e/widgets/everything/main");
-   edje_object_part_text_set(o, "e.text.label", cmd_buf);
 
    o = e_box_add(popup->evas);
    o_list = o;
@@ -150,12 +156,13 @@
    evas_object_show(o);
    e_popup_edje_bg_object_set(popup, o);
 
-   o = e_widget_toolbar_add(popup->evas, 48 * e_scale, 48 * e_scale);
-   e_widget_toolbar_scrollable_set(o, 0);
+   o = e_box_add(popup->evas);
+   e_box_orientation_set(o, 1);
+   e_box_homogenous_set(o, 1);
    edje_object_part_swallow(o_main, "e.swallow.bar", o);
    evas_object_show(o);
-   o_toolbar = o;
-
+   o_selector = o;
+   
    evas_event_thaw(popup->evas);
 
    handlers = eina_list_append
@@ -174,11 +181,7 @@
      (handlers, ecore_event_handler_add
       (ECORE_EVENT_MOUSE_WHEEL, _evry_cb_mouse_wheel, NULL));
 
-   _evry_matches_update();
-
-   ev_last_is_mouse = 0;
-   item_mouseover = NULL;
-   item_selected = NULL;
+   _evry_push_state();
    
    e_popup_show(popup);
    return 1;
@@ -191,9 +194,26 @@
    char *str;
    Evry_Plugin *plugin;
    Eina_List *l;
-
+   Evry_State *s;
+   
    if (!popup) return;
 
+   evas_event_freeze(popup->evas);
+
+   _evry_list_clear();
+     
+   EINA_LIST_FREE(stack, s)
+     {
+	Evry_Plugin *p;
+	
+	free(s->input);
+
+	EINA_LIST_FREE(s->plugins, p)
+	  p->class->free(p);
+     }
+   stack = NULL;
+   cur_state = NULL;
+   
    if (update_timer)
      {
 	ecore_timer_del(update_timer);
@@ -210,22 +230,13 @@
 	scroll_animator = NULL;
      }
    
-   evas_event_freeze(popup->evas);
-   _evry_matches_clear();
    e_popup_hide(popup);
-
-   e_box_freeze(o_list);
-   EINA_LIST_FOREACH(sources, l, plugin)
-     {
-	plugin->cleanup();
-     }
-   e_box_thaw(o_list);
-
+   
    evas_object_del(o_list);
    o_list = NULL;
 
-   evas_object_del(o_toolbar);
-   o_toolbar = NULL;
+   evas_object_del(o_selector);
+   o_selector = NULL;
 
    evas_object_del(o_main);
    o_main = NULL;
@@ -240,21 +251,184 @@
    ecore_x_window_free(input_window);
    e_grabinput_release(input_window, input_window);
    input_window = 0;
-   free(cmd_buf);
-   cmd_buf = NULL;
+}
 
-   cur_source = NULL;
-   item_selected = NULL;
-   item_mouseover = NULL;
+
+EAPI void
+evry_plugin_async_update(Evry_Plugin *plugin, int state)
+{
+   Evry_State *s;
+
+   if (!popup) return;
+
+   s = cur_state;
+   
+   if (!eina_list_data_find(s->cur_plugins, plugin))
+     {
+	s->cur_plugins = eina_list_append(s->cur_plugins, plugin);
+	_evry_plugin_selector_append(plugin); 
+     }
+
+   if (s->cur_plugin && eina_list_data_find(s->cur_plugins, s->cur_plugin))
+     _evry_show_items(s->cur_plugin);
+   else if (!s->cur_plugin && s->cur_plugins)
+     _evry_show_items(s->cur_plugins->data);
+   else if (s->cur_plugins && !eina_list_data_find(s->cur_plugins, s->cur_plugin))
+     _evry_show_items(s->cur_plugins->data);
 }
 
 /* local subsystem functions */
 static int
+_evry_cb_plugin_sort(const void *data1, const void *data2)
+{
+   const Evry_Plugin *p1 = data1;
+   const Evry_Plugin *p2 = data2;
+   return p1->class->prio - p2->class->prio;
+}
+
+
+static int
+_evry_push_state(void)
+{
+   Evry_State *s;
+   Eina_List *l, *list = NULL; 
+   Evry_Plugin_Class *pc;
+   const char *expect_type = "NONE";
+   Evry_Plugin *p;
+   
+   s = cur_state;
+
+   if (s)
+     {
+	expect_type = s->cur_plugin->class->type_out;
+	if (!strcmp(expect_type, "NONE") || !s->sel_item)
+	  return 0;
+     }
+
+   EINA_LIST_FOREACH(plugins, l, pc)
+     {	
+	if (strstr(pc->type_in, expect_type))
+	  {
+	     p = pc->new();
+
+	     if (!p) continue;
+
+	     if (cur_state && p->begin)
+	       {
+		  if (p->begin(p, cur_state->sel_item))
+		    list = eina_list_append(list, p);
+		  else
+		    p->class->free(p);
+	       }
+	     else
+	       list = eina_list_append(list, p);
+	  }
+     }
+   
+   if (!list) return 0;
+
+   list = eina_list_sort(list, eina_list_count(list), _evry_cb_plugin_sort);
+   
+   _evry_list_clear();
+
+   if (s)
+     {
+	EINA_LIST_FOREACH(s->cur_plugins, l, p)
+	  {
+	     evas_object_del(p->tab);
+	     p->tab = NULL;
+	  }
+     }
+   
+   s = E_NEW(Evry_State, 1);
+   s->input = malloc(INPUTLEN);
+   s->input[0] = 0;
+   s->plugins = list;
+   s->cur_plugins = NULL;
+   s->sel_item = NULL;
+   s->initial = (cur_state ? 0 : 1);
+   cur_state = s;
+   stack = eina_list_prepend(stack, s);
+
+   edje_object_part_text_set(o_main, "e.text.label", s->input);
+
+   ev_last_is_mouse = 0;
+   item_mouseover = NULL;
+
+   _evry_matches_update();
+
+   return 1;
+}
+
+static int
+_evry_pop_state(void)
+{
+   Evry_State *s = cur_state;
+   Evry_Plugin *p;
+   Eina_List *l;
+   
+   _evry_list_clear();
+
+   EINA_LIST_FREE(s->cur_plugins, p)
+     {
+	evas_object_del(p->tab);
+	p->tab = NULL;
+     }
+   
+   free(s->input);
+
+   EINA_LIST_FOREACH(s->plugins, l, p)
+     p->class->free(p);
+
+   E_FREE(s);
+
+   stack = eina_list_remove_list(stack, stack);
+
+   if (stack)
+     {
+	s = stack->data;
+	cur_state = s;
+
+	edje_object_part_text_set(o_main, "e.text.label", s->input);
+
+	EINA_LIST_FOREACH(s->cur_plugins, l, p)
+	  _evry_plugin_selector_append(p); 
+
+	_evry_show_items(s->cur_plugin);
+
+	if (s->sel_item)
+	  {
+	     Evry_Item *it;
+	     int i = 0;
+
+	     _evry_item_sel(s->sel_item);
+	     
+	     EINA_LIST_FOREACH(s->cur_plugin->items, l, it)
+	       if (it == s->sel_item)
+		 break;
+	       else i++;
+	     
+	     _evry_scroll_to(i);
+	  }
+     }
+   else
+     {
+	cur_state = NULL;
+	evry_hide();
+     }
+
+   ev_last_is_mouse = 0;
+   item_mouseover = NULL;
+}
+
+
+static int
 _evry_cb_key_down(void *data, int type, void *event)
 {
    Ecore_Event_Key *ev;
-
+   Evry_State *s = cur_state;
    ev_last_is_mouse = 0;
+   item_mouseover = NULL;
 
    ev = event;
    if (ev->event_window != input_window) return 1;
@@ -272,13 +446,18 @@
      _evry_action(0);
    else if (!strcmp(ev->key, "Return"))
      _evry_action(1);
-   /* else if (!strcmp(ev->key, "Tab"))
-    *   _evry_complete(); */
+   else if (!strcmp(ev->key, "Tab"))
+     {
+	if (s->sel_item)
+	  _evry_push_state();
+     }
    else if (!strcmp(ev->key, "u") &&
 	    (ev->modifiers & ECORE_EVENT_MODIFIER_CTRL))
      _evry_clear();
-   else  if (!strcmp(ev->key, "Escape"))
-     evry_hide();
+   else  if ((!strcmp(ev->key, "Escape")) ||
+	     (!strcmp(ev->key, "g") &&
+	      (ev->modifiers & ECORE_EVENT_MODIFIER_CTRL)))
+	_evry_pop_state();
    else if (!strcmp(ev->key, "BackSpace"))
      _evry_backspace();
    else if (!strcmp(ev->key, "Delete"))
@@ -287,9 +466,9 @@
      {
    	if (ev->compose)
    	  {
-   	     if ((strlen(cmd_buf) < (INPUTLEN - strlen(ev->compose))))
+   	     if ((strlen(s->input) < (INPUTLEN - strlen(ev->compose))))
    	       {
-   		  strcat(cmd_buf, ev->compose);
+   		  strcat(s->input, ev->compose);
    		  _evry_update();
    	       }
    	  }
@@ -301,17 +480,18 @@
 _evry_cb_mouse_down(void *data, int type, void *event)
 {
    Ecore_Event_Mouse_Button *ev;
+   Evry_State *s =cur_state;
    
    ev = event;
    if (ev->event_window != input_window) return 1;
 
    if (item_mouseover)
      {
-	if (item_selected != item_mouseover)
+	if (s->sel_item != item_mouseover)
 	  {
-	     if (item_selected) _evry_item_desel(item_selected);
-	     item_selected = item_mouseover;
-	     _evry_item_sel(item_selected); 
+	     if (s->sel_item) _evry_item_desel(s->sel_item);
+	     s->sel_item = item_mouseover;
+	     _evry_item_sel(s->sel_item); 
 	  }   
      }
    else
@@ -349,7 +529,8 @@
 _evry_cb_mouse_move(void *data, int type, void *event)
 {
    Ecore_Event_Mouse_Move *ev;
-
+   Evry_State *s =cur_state;
+   
    ev = event;
    if (ev->event_window != input_window) return 1;
 
@@ -358,12 +539,12 @@
         ev_last_is_mouse = 1;
         if (item_mouseover)
           {
-             if (item_selected && (item_selected != item_mouseover))
-               _evry_item_desel(item_selected);
-             if (!item_selected || (item_selected != item_mouseover))
+             if (s->sel_item && (s->sel_item != item_mouseover))
+               _evry_item_desel(s->sel_item);
+             if (!s->sel_item || (s->sel_item != item_mouseover))
                {
-                  item_selected = item_mouseover;
-                  _evry_item_sel(item_selected); 
+                  s->sel_item = item_mouseover;
+                  _evry_item_sel(s->sel_item); 
                }
           }
      }
@@ -403,12 +584,15 @@
 _evry_cb_item_mouse_in(void *data, Evas *evas, Evas_Object *obj, 
 			   void *event_info)
 {
-   item_mouseover = data;
+   Evry_State *s =cur_state;
+   
    if (!ev_last_is_mouse) return;
 
-   if (item_selected) _evry_item_desel(item_selected);
-   if (!(item_selected = data)) return;
-   _evry_item_sel(item_selected);
+   item_mouseover = data;
+   
+   if (s->sel_item) _evry_item_desel(s->sel_item);
+   if (!(s->sel_item = data)) return;
+   _evry_item_sel(s->sel_item);
 }
 
 static void 
@@ -418,27 +602,19 @@
    item_mouseover = NULL;
 }
 
-
 static void
-_evry_cb_plugin_sel(void *data1, void *data2)
-{
-   if (cur_source == data1) return;
-   
-   _evry_show_candidates(data1);
-}
-
-static void
 _evry_backspace(void)
 {
    int len, val, pos;
-
-   len = strlen(cmd_buf);
+   Evry_State *s = cur_state;
+   
+   len = strlen(s->input);
    if (len > 0)
      {
-	pos = evas_string_char_prev_get(cmd_buf, len, &val);
+	pos = evas_string_char_prev_get(s->input, len, &val);
 	if ((pos < len) && (pos >= 0))
 	  {
-	     cmd_buf[pos] = 0;
+	     s->input[pos] = 0;
 	     _evry_update();
 	  }
      }
@@ -449,25 +625,37 @@
 {
    Efreet_Desktop *desktop;
    Evas_Object *o;
+   
+   edje_object_part_text_set(o_main, "e.text.label", cur_state->input);
 
-   edje_object_part_text_set(o_main, "e.text.label", cmd_buf);
-
-   if (icon_object) evas_object_del(icon_object);
-   icon_object = NULL;
-
    if (update_timer) ecore_timer_del(update_timer);
    update_timer = ecore_timer_add(MATCH_LAG, _evry_update_timer, NULL);
 }
 
+static int
+_evry_update_timer(void *data)
+{
+   _evry_matches_update();
+   update_timer = NULL;
+   return 0;
+}
+
 static void
 _evry_action(int finished)
 {
-   if (cur_source && item_selected)
+   Evry_State *s = cur_state;
+
+   if (s->cur_plugin && (s->sel_item || s->input))
      {
-	cur_source->action(item_selected);
+	if (!s->cur_plugin->action ||
+	    !s->cur_plugin->action(s->cur_plugin, s->sel_item, s->input))
+	  {
+	     _evry_push_state();
+	     finished = 0;
+	  }
      }
-   else
-     e_exec(popup->zone, NULL, cmd_buf, NULL, "everything");
+   else if (s->initial)
+     e_exec(popup->zone, NULL, s->input, NULL, NULL /* "everything" */);
 
    if (finished)
      evry_hide();
@@ -476,9 +664,9 @@
 static void
 _evry_clear(void)
 {
-   if (cmd_buf[0] != 0)
+   if (cur_state->input[0] != 0)
      {
-	cmd_buf[0] = 0;
+	cur_state->input[0] = 0;
 	_evry_update();
 	if (!update_timer)
 	  update_timer = ecore_timer_add(MATCH_LAG, _evry_update_timer, NULL);
@@ -486,20 +674,33 @@
 }
 
 static void
-_evry_show_candidates(Evry_Plugin *plugin)
+_evry_show_items(Evry_Plugin *p)
 {
    Evry_Item *it;
    Eina_List *l;
    int mw, mh, h;
    Evas_Object *o;
-   int i = 0;
+   Evry_State *s = cur_state;
+   
+   _evry_list_clear();
 
-   _evry_list_clear();
-   cur_source = plugin;
+   if (s->cur_plugin) 
+     edje_object_signal_emit(s->cur_plugin->tab, "e,state,unselected", "e");
+
+   if (s->cur_plugin != p)
+     s->sel_item = NULL;
    
+   s->cur_plugin = p;
+   
+   /* XXX remove this */
+   if (!s->cur_plugin) return;
+
+   edje_object_signal_emit(p->tab, "e,state,selected", "e");
+   
+   evas_event_freeze(popup->evas);   
    e_box_freeze(o_list);
 
-   EINA_LIST_FOREACH(cur_source->candidates, l, it)
+   EINA_LIST_FOREACH(p->items, l, it)
      {
 	o = edje_object_add(popup->evas);
 	it->o_bg = o;
@@ -514,7 +715,7 @@
 					 _evry_cb_item_mouse_out, it);
 	evas_object_show(o);
 
-	cur_source->icon_get(it, popup->evas);
+	p->icon_get(p, it, popup->evas);
 	if (edje_object_part_exists(o, "e.swallow.icons") && it->o_icon)
 	  {
 	     edje_object_part_swallow(o, "e.swallow.icons", it->o_icon);
@@ -522,13 +723,7 @@
 	  }
 	edje_object_size_min_calc(o, &mw, &mh);
 	e_box_pack_end(o_list, o);
-	e_box_pack_options_set(o,
-			       1, 1, /* fill */
-			       1, 0, /* expand */
-			       0.5, 0.5, /* align */
-			       mw, mh, /* min */
-			       9999, mh /* max */
-			       );
+	e_box_pack_options_set(o, 1, 1, 1, 0, 0.5, 0.5, mw, mh, 9999, mh);
      }
    e_box_thaw(o_list);
 
@@ -539,112 +734,86 @@
    else
      e_box_align_set(o_list, 0.5, 1.0);
 
-   EINA_LIST_FOREACH(cur_sources, l, plugin)
-     if (plugin == cur_source)
-       break;
-     else i++;
+   /* TODO add option */
 
-   e_widget_toolbar_item_select(o_toolbar, i);
+   if (!s->sel_item && p->items)
+     {
+	s->sel_item = p->items->data; 
+	_evry_item_sel(s->sel_item); 
+	_evry_scroll_to(0); 
+     }
    
    evas_event_thaw(popup->evas);
 }
 
 static void
-_evry_matches_update()
+_evry_matches_update(void)
 {
-   Evry_Plugin *plugin;
+   Evry_Plugin *p;
    Eina_List *l;
-   char buf[64];
-   int candidates;
-   int plugin_count = 0;
+   int items;
+   Evry_State *s = cur_state;
    
-   _evry_matches_clear();
-
-   eina_list_free(cur_sources);
-   cur_sources = NULL;
+   _evry_list_clear();
    
-   EINA_LIST_FOREACH(sources, l, plugin)
+   EINA_LIST_FREE(s->cur_plugins, p)
      {
-	if (strlen(cmd_buf) == 0)
+	evas_object_del(p->tab);
+	p->tab = NULL;
+     }
+   
+   s->cur_plugins = NULL;
+   s->sel_item = NULL;
+   
+   EINA_LIST_FOREACH(s->plugins, l, p)
+     {
+	if (strlen(s->input) == 0)
+	  items = !p->class->need_query ? p->fetch(p, NULL) : 0;
+	else
+	  items = p->fetch(p, s->input);
+	
+	if (!s->initial || (items && eina_list_count(p->items) > 0))
 	  {
-	     candidates = !plugin->need_query ? plugin->fetch(NULL) : 0;
+	     s->cur_plugins = eina_list_append(s->cur_plugins, p);
+	     _evry_plugin_selector_append(p); 
 	  }
-	else
+     }
+   
+   if (s->cur_plugins)
+     {
+	if (s->cur_plugin && eina_list_data_find(s->cur_plugins, s->cur_plugin))
 	  {
-	     candidates = plugin->fetch(cmd_buf);
+	     _evry_show_items(s->cur_plugin);
 	  }
-	if (candidates)
+	else
 	  {
-	     snprintf(buf, 64, "%s (%d)", plugin->name,
-		      eina_list_count(plugin->candidates));
-
-	     e_widget_toolbar_item_append(o_toolbar, NULL, buf,
-					  _evry_cb_plugin_sel, plugin, NULL);
-
-	     cur_sources = eina_list_append(cur_sources, plugin);
-	     plugin_count++;
+	     _evry_show_items(s->cur_plugins->data);
 	  }
      }
-
-   if ((!cur_source || !eina_list_data_find(cur_sources, cur_source)) &&
-       (plugin_count > 0))
-     {
-	_evry_show_candidates(cur_sources->data);
-     }
-
-   else if (cur_source)
-     {
-	_evry_show_candidates(cur_source);
-     }
+   else s->cur_plugin = NULL;
 }
 
 static void
-_evry_item_remove(Evry_Item *it)
-{
-   evas_object_del(it->o_bg);
-   if (it->o_icon) evas_object_del(it->o_icon);
-   it->o_icon = NULL;
-}
-
-static void
-_evry_matches_clear(void)
-{
-   Evry_Plugin *plugin;
-   Eina_List *l;
-
-   // FIXME add toolbar item remove method or use sth different
-   evas_object_del(o_toolbar);
-   Evas_Object *o = e_widget_toolbar_add(popup->evas,
-					 48 * e_scale,
-					 48 * e_scale);
-   e_widget_toolbar_scrollable_set(o, 0);
-   edje_object_part_swallow(o_main, "e.swallow.bar", o);
-   evas_object_show(o);
-   o_toolbar = o;
-
-   _evry_list_clear();
-
-   EINA_LIST_FOREACH(sources, l, plugin)
-     plugin->cleanup();
-}
-
-static void
 _evry_list_clear(void)
 {
-   Evry_Item *it;
-   Eina_List *l;
+   Evry_State *s = cur_state;
 
-   if (cur_source)
+   if (s && s->cur_plugin)
      {
+	Evry_Item *it;
+	Eina_List *l;
+	
 	evas_event_freeze(popup->evas);
 	e_box_freeze(o_list);
-	EINA_LIST_FOREACH(cur_source->candidates, l, it)
-	  _evry_item_remove(it);
+	EINA_LIST_FOREACH(s->cur_plugin->items, l, it)
+	  {
+	     evas_object_del(it->o_bg);
+	     if (it->o_icon) evas_object_del(it->o_icon);
+	     it->o_icon = NULL;
+	  }
 	e_box_thaw(o_list);
 	evas_event_thaw(popup->evas);
      }
-
-   item_selected = NULL;
 }
 
 static void
@@ -652,7 +821,7 @@
 {
    int n, h, mh;
 
-   n = eina_list_count(cur_source->candidates);
+   n = eina_list_count(cur_state->cur_plugin->items);
 
    e_box_min_size_get(o_list, NULL, &mh);
    evas_object_geometry_get(o_list, NULL, NULL, NULL, &h);
@@ -695,46 +864,39 @@
      edje_object_signal_emit(it->o_icon, "e,state,selected", "e");
 }
 
-static int
-_evry_update_timer(void *data)
-{
-   _evry_matches_update();
-   update_timer = NULL;
-   return 0;
-}
-
 static void
 _evry_item_next(void)
 {
    Eina_List *l;
    int i;
+   Evry_State *s = cur_state;
    
-   if (item_selected)
+   if (s->sel_item)
      {
-	for (i = 0, l = cur_source->candidates; l; l = l->next, i++)
+	for (i = 0, l = s->cur_plugin->items; l; l = l->next, i++)
 	  {
-	     if (l->data == item_selected)
+	     if (l->data == s->sel_item)
 	       {
 		  if (l->next)
 		    {
-		       _evry_item_desel(item_selected);
-		       item_selected = l->next->data;
-		       _evry_item_sel(item_selected);
+		       _evry_item_desel(s->sel_item);
+		       s->sel_item = l->next->data;
+		       _evry_item_sel(s->sel_item);
 		       _evry_scroll_to(i + 1);
 		    }
 		  break;
 	       }
 	  }
      }
-   else if (cur_source->candidates)
+   else if (s->cur_plugin && s->cur_plugin->items)
      {
-	item_selected = cur_source->candidates->data;
-	_evry_item_sel(item_selected);
+	s->sel_item = s->cur_plugin->items->data;
+	_evry_item_sel(s->sel_item);
 	_evry_scroll_to(0);
      }
 
-   /* if (item_selected)
-    *   edje_object_part_text_set(o_main, "e.text.label", item_selected->label); */
+   /* if (s->sel_item)
+    *   edje_object_part_text_set(o_main, "e.text.label", s->sel_item->label); */
 }
 
 static void
@@ -742,31 +904,32 @@
 {
    Eina_List *l;
    int i;
+   Evry_State *s = cur_state;
    
-   if (item_selected)
+   if (s->sel_item)
      {
-	_evry_item_desel(item_selected);
+	_evry_item_desel(s->sel_item);
 
-	for (i = 0, l = cur_source->candidates; l; l = l->next, i++)
+	for (i = 0, l = s->cur_plugin->items; l; l = l->next, i++)
 	  {
-	     if (l->data == item_selected)
+	     if (l->data == s->sel_item)
 	       {
 		  if (l->prev)
 		    {
-		       item_selected = l->prev->data;
-		       _evry_item_sel(item_selected);
+		       s->sel_item = l->prev->data;
+		       _evry_item_sel(s->sel_item);
 		       _evry_scroll_to(i - 1);
 		    }
 		  else
-		    item_selected = NULL;
+		    s->sel_item = NULL;
 		  break;
 	       }
 	  }
      }
-   /* if (item_selected)
-    *   edje_object_part_text_set(o_main, "e.text.label", item_selected->label);
+   /* if (s->sel_item)
+    *   edje_object_part_text_set(o_main, "e.text.label", s->sel_item->label);
     * else
-    *   edje_object_part_text_set(o_main, "e.text.label", cmd_buf); */
+    *   edje_object_part_text_set(o_main, "e.text.label", input); */
 }
 
 static void
@@ -774,18 +937,19 @@
 {
    Eina_List *l;
    Evry_Plugin *plugin;
+   Evry_State *s = cur_state;
+   
+   if (!s->cur_plugin) return;
 
-   if (!cur_source) return;
+   l = eina_list_data_find_list(s->cur_plugins, s->cur_plugin);
 
-   l = eina_list_data_find_list(cur_sources, cur_source);
-
    if (l && l->next)
      {
-	_evry_show_candidates(l->next->data);
+	_evry_show_items(l->next->data);
      }
-   else if (cur_source != cur_sources->data)
+   else if (s->cur_plugin != s->cur_plugins->data)
      {
-	_evry_show_candidates(cur_sources->data);
+	_evry_show_items(s->cur_plugins->data);
      }
 }
 
@@ -795,22 +959,23 @@
 {
    Eina_List *l;
    Evry_Plugin *plugin;
+   Evry_State *s = cur_state;
+   
+   if (!s->cur_plugin) return;
 
-   if (!cur_source) return;
+   l = eina_list_data_find_list(s->cur_plugins, s->cur_plugin);
 
-   l = eina_list_data_find_list(cur_sources, cur_source);
-
    if (l && l->prev)
      {
-	_evry_show_candidates(l->prev->data);
+	_evry_show_items(l->prev->data);
      }
    else
      {	
-	l = eina_list_last(cur_sources);
+	l = eina_list_last(s->cur_plugins);
 	
-	if (cur_source != l->data)
+	if (s->cur_plugin != l->data)
 	  {
-	     _evry_show_candidates(l->data);
+	     _evry_show_items(l->data);
 	  }
      }
 }
@@ -849,3 +1014,35 @@
    return 0;
 }
 
+static void
+_evry_plugin_selector_append(Evry_Plugin *p)
+{
+   Evas_Object *o;
+   Evas_Coord mw = 0, mh = 0;
+   char buf[64];
+
+   o = edje_object_add(popup->evas);
+   /* TODO move this to everything theme group !*/
+   e_theme_edje_object_set(o, "base/theme/widgets",
+                           "e/widgets/toolbar/item");
+
+   snprintf(buf, 64, "%s (%d)", p->class->name, eina_list_count(p->items));
+   
+   edje_object_part_text_set(o, "e.text.label", buf);
+
+   edje_object_size_min_calc(o, &mw, &mh);
+   e_box_pack_end(o_selector, o);
+
+   evas_object_show(o);
+   e_box_pack_options_set(o,
+			  1, 1, /* fill */
+			  0, 0, /* expand */
+			  0.5, 0.5, /* align */
+			  mw, mh, /* min */
+			  9999, 9999 /* max */
+			  );
+
+   p->tab = o;
+}
+
+
Index: e/src/modules/everything/e_mod_main.c
===================================================================
--- e/src/modules/everything/e_mod_main.c	(revision 41007)
+++ e/src/modules/everything/e_mod_main.c	(revision 41162)
@@ -73,6 +73,8 @@
    evry_plug_border_init();
    evry_plug_apps_init();
    evry_plug_config_init();
+   evry_plug_dir_browse_init();
+   evry_plug_tracker_init();
 
    /* add module supplied action */
    act = e_action_add("everything");
@@ -110,6 +112,8 @@
    evry_plug_border_shutdown();
    evry_plug_apps_shutdown();
    evry_plug_config_shutdown();
+   evry_plug_dir_browse_shutdown();
+   evry_plug_tracker_shutdown();
 
    evry_shutdown();
    conf_module = NULL;
Index: e/src/modules/everything/evry_plug_tracker.c
===================================================================
--- e/src/modules/everything/evry_plug_tracker.c	(revision 0)
+++ e/src/modules/everything/evry_plug_tracker.c	(revision 41162)
@@ -0,0 +1,226 @@
+#include "e.h"
+#include "e_mod_main.h"
+
+/* TODO check if trackerd is running */
+
+typedef struct _Inst Inst;
+
+struct _Inst
+{
+  E_DBus_Connection *conn;
+};
+
+static Evry_Plugin *_plug_new();
+static void _plug_free(Evry_Plugin *p);
+static int  _fetch(Evry_Plugin *p, const char *input);
+static int  _action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _cleanup(Evry_Plugin *p);
+static void _item_add(Evry_Plugin *p, char *file, char *service, char *mime, int prio);
+static void _item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+static void _dbus_cb_reply(void *data, DBusMessage *msg, DBusError *error);
+
+static Evry_Plugin_Class class;
+
+EAPI int
+evry_plug_tracker_init(void)
+{
+   class.name = "Search Files";
+   class.type_in = "NONE";
+   class.type_out = "FILE";
+   class.need_query = 1;
+   class.new = &_plug_new;
+   class.free = &_plug_free;
+   evry_plugin_register(&class);
+   
+   return 1;
+}
+
+EAPI int
+evry_plug_tracker_shutdown(void)
+{
+   evry_plugin_unregister(&class);
+   
+   return 1;
+}
+
+static Evry_Plugin *
+_plug_new()
+{
+   Evry_Plugin *p;
+   Inst *inst;
+   E_DBus_Connection *conn = e_dbus_bus_get(DBUS_BUS_SESSION);
+
+   if (!conn) return NULL;
+   
+   p = E_NEW(Evry_Plugin, 1);
+   p->class = &class;
+   p->fetch = &_fetch;
+   p->action = &_action;
+   p->cleanup = &_cleanup;
+   p->icon_get = &_item_icon_get;
+   p->items = NULL;   
+
+   inst = E_NEW(Inst, 1);
+   inst->conn = conn;
+   p->priv = inst;
+
+   return p;
+}
+
+static void
+_plug_free(Evry_Plugin *p)
+{
+   Inst *inst = p->priv;
+   
+   _cleanup(p);
+   e_dbus_connection_close(inst->conn);
+
+   E_FREE(inst);
+   E_FREE(p);
+}
+
+static int
+_action(Evry_Plugin *p, Evry_Item *it, const char *input)
+{
+   return 0;
+}
+
+static void
+_cleanup(Evry_Plugin *p)
+{
+   Evry_Item *it;
+   
+   EINA_LIST_FREE(p->items, it)
+     {
+	if (it->mime) eina_stringshare_del(it->mime);
+	if (it->uri) eina_stringshare_del(it->uri);
+	if (it->label) eina_stringshare_del(it->label);
+	if (it->o_icon) evas_object_del(it->o_icon);
+	free(it);
+     }
+}
+
+static int
+_fetch(Evry_Plugin *p, const char *input)
+{
+   Eina_List *list;
+   DBusMessage *msg;
+   DBusMessageIter iter;
+   int live_query_id = 0;
+   int offset = 0;
+   int max_hits = 50;
+   char *service = "Files";
+   char *match;
+   Inst *inst = p->priv;
+   
+   _cleanup(p); 
+
+   match = malloc(sizeof(char) * strlen(input) + 2);
+   sprintf(match, "%s*", input);
+
+   msg = dbus_message_new_method_call("org.freedesktop.Tracker",
+				      "/org/freedesktop/Tracker/Search",
+				      "org.freedesktop.Tracker.Search",
+				      "TextDetailed");
+
+   dbus_message_iter_init_append(msg, &iter);
+   dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32,  &live_query_id);
+   dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &service);
+   dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &match);
+   dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32,  &offset);
+   dbus_message_iter_append_basic(&iter, DBUS_TYPE_INT32,  &max_hits);
+   e_dbus_message_send(inst->conn, msg, _dbus_cb_reply, -1, p);
+   dbus_message_unref(msg);
+
+   free(match);
+
+   return 0;
+}
+
+static void
+_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
+{
+   char *item_path;
+
+   if (!strcmp(it->mime, "Folder"))
+     {
+	it->o_icon = edje_object_add(e);
+	/* e_util_icon_theme_set(it->o_icon, "folder"); */
+	e_theme_edje_object_set(it->o_icon, "base/theme/fileman", "e/icons/folder");
+     }
+   else
+     {
+	item_path = efreet_mime_type_icon_get(it->mime, e_config->icon_theme, 32);
+
+	if (item_path)
+	  it->o_icon = e_util_icon_add(item_path, e);
+	else
+	  {
+	     it->o_icon = edje_object_add(e);
+	     /* e_util_icon_theme_set(it->o_icon, "file"); */
+	     e_theme_edje_object_set(it->o_icon, "base/theme/fileman", "e/icons/fileman/file");
+	  }
+     }
+}
+
+static void
+_item_add(Evry_Plugin *p, char *file, char *service, char *mime, int prio)
+{
+   Evry_Item *it;   
+   
+   it = E_NEW(Evry_Item, 1);
+   it->priority = prio;
+   it->label = eina_stringshare_add(ecore_file_file_get(file));
+   it->uri = eina_stringshare_add(file);
+   it->mime = eina_stringshare_add(mime);
+   it->o_icon = NULL;
+
+   p->items = eina_list_append(p->items, it);
+}
+
+static void
+_dbus_cb_reply(void *data, DBusMessage *msg, DBusError *error)
+{
+   DBusMessageIter array, iter, item;
+   char *val;
+   Evry_Plugin *p = data;
+   
+   if (dbus_error_is_set(error))
+     {
+	printf("Error: %s - %s\n", error->name, error->message);
+	return;
+     }
+
+   dbus_message_iter_init(msg, &array);
+   if(dbus_message_iter_get_arg_type(&array) == DBUS_TYPE_ARRAY)
+     {
+	dbus_message_iter_recurse(&array, &item);
+	while(dbus_message_iter_get_arg_type(&item) == DBUS_TYPE_ARRAY)
+	  {
+	     char *uri;
+	     char *service;
+	     char *mime;
+	     
+	     dbus_message_iter_recurse(&item, &iter);
+	     
+	     if (dbus_message_iter_get_arg_type(&iter) == DBUS_TYPE_STRING)
+	       {
+		  dbus_message_iter_get_basic(&iter, &uri);
+		  dbus_message_iter_next(&iter);
+		  dbus_message_iter_get_basic(&iter, &service);
+		  dbus_message_iter_next(&iter);
+		  dbus_message_iter_get_basic(&iter, &mime);
+
+		  if (uri && service && mime)
+		    {
+		       _item_add(p, uri, service, mime, 1); 
+		    }
+	       }
+	     
+	     dbus_message_iter_next(&item);
+	  }
+     }
+   
+   if (p->items) evry_plugin_async_update(p, 1); 
+}
+
Index: e/src/modules/everything/Makefile.am
===================================================================
--- e/src/modules/everything/Makefile.am	(revision 41007)
+++ e/src/modules/everything/Makefile.am	(revision 41162)
@@ -22,9 +22,11 @@
                          e_mod_main.h \
 			 evry.c \
                          evry.h \
+			 evry_plug_config.c \
 			 evry_plug_apps.c \
+			 evry_plug_tracker.c \
 			 evry_plug_border.c \
-			 evry_plug_config.c
+			 evry_plug_dir_browse.c 
 
 module_la_LIBADD       = @e_libs@ @dlopen_libs@
 module_la_LDFLAGS      = -module -avoid-version
@@ -32,3 +34,4 @@
 
 uninstall:
 	rm -rf $(DESTDIR)$(libdir)/enlightenment/modules/$(MODULE)
+
Index: e/src/modules/everything/evry_plug_border.c
===================================================================
--- e/src/modules/everything/evry_plug_border.c	(revision 41007)
+++ e/src/modules/everything/evry_plug_border.c	(revision 41162)
@@ -1,32 +1,55 @@
 #include "e.h"
 #include "e_mod_main.h"
 
-static Evry_Plugin plugin;
-static Evry_Action act_close;
+typedef struct _Inst Inst;
 
-static int  _evry_plug_border_fetch(char *string);
-static int  _evry_plug_border_action(Evry_Item *item);
-static void _evry_plug_border_cleanup(void);
-static void _evry_plug_border_item_add(E_Border *bd, int prio);
-static int  _evry_plug_border_cb_sort(const void *data1, const void *data2);
-static void _evry_plug_border_item_icon_get(Evry_Item *it, Evas *e);
+struct _Inst
+{
+  E_Border *border;
+};
 
+static Evry_Plugin * _src_border_new(void);
+static void _src_border_free(Evry_Plugin *p);
+static int  _src_border_fetch(Evry_Plugin *p, const char *input);
+static int  _src_border_action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _src_border_cleanup(Evry_Plugin *p);
+static void _src_border_item_add(Evry_Plugin *p, E_Border *bd, int prio);
+static int  _src_border_cb_sort(const void *data1, const void *data2);
+static void _src_border_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+
+static Evry_Plugin * _act_border_new(void);
+static void _act_border_free(Evry_Plugin *p);
+static int  _act_border_begin(Evry_Plugin *p, Evry_Item *item);
+static int  _act_border_fetch(Evry_Plugin *p, const char *input);
+static int  _act_border_action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _act_border_cleanup(Evry_Plugin *p);
+static void _act_border_item_add(Evry_Plugin *p, const char *label, void (*action_cb) (E_Border *bd), const char *icon);
+static void _act_border_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+
+static Evry_Plugin_Class source;
+static Evry_Plugin_Class action;
+
+
 EAPI int
 evry_plug_border_init(void)
 {
-   plugin.name = "Windows";
-   plugin.type = "BORDER";
-   plugin.need_query = 0;
-   plugin.fetch  = &_evry_plug_border_fetch;
-   plugin.action = &_evry_plug_border_action;
-   plugin.cleanup = &_evry_plug_border_cleanup;
-   plugin.icon_get = &_evry_plug_border_item_icon_get;
-   plugin.candidates = NULL;   
-   evry_plugin_add(&plugin);
+   source.name = "Windows";
+   source.type_in  = "NONE";
+   source.type_out = "BORDER";
+   source.need_query = 0;
+   source.prio = 0;
+   source.new = &_src_border_new;
+   source.free = &_src_border_free;
+   evry_plugin_register(&source);
 
-   /* act_close.name = "Close";
-    * act_close.type = "BORDER";
-    * evry_action_add(&act_close); */
+   action.name = "Window Action";
+   action.type_in  = "BORDER";
+   action.type_out = "NONE";
+   action.need_query = 0;
+   action.prio = 0;
+   action.new = &_act_border_new;
+   action.free = &_act_border_free;
+   evry_plugin_register(&action);
    
    return 1;
 }
@@ -34,19 +57,45 @@
 EAPI int
 evry_plug_border_shutdown(void)
 {
-   evry_plugin_remove(&plugin);
-   /* evry_action_remove(&act_close); */
+   evry_plugin_unregister(&source);
+   evry_plugin_unregister(&action);
    
    return 1;
 }
 
+static Evry_Plugin *
+_src_border_new()
+{
+   Evry_Plugin *p;
+   
+   p = E_NEW(Evry_Plugin, 1);
+   p->class = &source;
+   p->fetch = &_src_border_fetch;
+   p->action = &_src_border_action;
+   p->cleanup = &_src_border_cleanup;
+   p->icon_get = &_src_border_item_icon_get;
+   p->items = NULL;   
+
+   return p;
+}
+
+static void
+_src_border_free(Evry_Plugin *p)
+{
+   _src_border_cleanup(p);
+   E_FREE(p);
+}
+
+
 static int
-_evry_plug_border_action(Evry_Item *item)
+_src_border_action(Evry_Plugin *p, Evry_Item *it, const char *input)
 {
    E_Border *bd;
    E_Zone *zone;
+
+   if (!it) return 0;
    
-   bd = (E_Border *)item->data;
+   bd = (E_Border *)it->data[0];
    zone = e_util_zone_current_get(e_manager_current_get());
    
    if (bd->desk != (e_desk_current_get(zone)))
@@ -67,13 +116,13 @@
 }
 
 static void
-_evry_plug_border_cleanup(void)
+_src_border_cleanup(Evry_Plugin *p)
 {
    Evry_Item *it;
 
-   EINA_LIST_FREE(plugin.candidates, it)
+   EINA_LIST_FREE(p->items, it)
      {
-	if (it->data) e_object_unref(E_OBJECT(it->data));
+	/* if (it->data[0]) e_object_unref(E_OBJECT(it->data[0])); */
 	if (it->label) eina_stringshare_del(it->label);
 	if (it->o_icon) evas_object_del(it->o_icon);
 	free(it);
@@ -81,7 +130,7 @@
 }
 
 static int
-_evry_plug_border_fetch(char *string)
+_src_border_fetch(Evry_Plugin *p, const char *input)
 {
    E_Manager *man;
    E_Zone *zone;
@@ -92,15 +141,15 @@
    E_Border *bd;
    E_Border_List *bl;
 
-   _evry_plug_border_cleanup(); 
+   _src_border_cleanup(p); 
 
    man = e_manager_current_get();
    zone = e_util_zone_current_get(man);
    
-   if (string)
+   if (input)
      {
-	snprintf(match1, sizeof(match1), "%s*", string);
-	snprintf(match2, sizeof(match2), "*%s*", string);
+	snprintf(match1, sizeof(match1), "%s*", input);
+	snprintf(match2, sizeof(match2), "*%s*", input);
      }
    
    bl = e_container_border_list_first(e_container_current_get(man));
@@ -108,25 +157,26 @@
      {
 	if (zone == bd->zone)
 	  {
-	     if (!string)
-	       _evry_plug_border_item_add(bd, 1);
-	     else if (bd->client.icccm.name && e_util_glob_case_match(bd->client.icccm.name, match1))
-	       _evry_plug_border_item_add(bd, 1);
+	     if (!input)
+	       _src_border_item_add(p, bd, 1);
+	     else if (bd->client.icccm.name &&
+		      e_util_glob_case_match(bd->client.icccm.name, match1))
+	       _src_border_item_add(p, bd, 1);
 	     else  if (e_util_glob_case_match(e_border_name_get(bd), match1))
-	       _evry_plug_border_item_add(bd, 1);
-	     else if (bd->client.icccm.name && e_util_glob_case_match(bd->client.icccm.name, match2))
-	       _evry_plug_border_item_add(bd, 2);
+	       _src_border_item_add(p, bd, 1);
+	     else if (bd->client.icccm.name &&
+		      e_util_glob_case_match(bd->client.icccm.name, match2))
+	       _src_border_item_add(p, bd, 2);
 	     else if (e_util_glob_case_match(e_border_name_get(bd), match2))
-	       _evry_plug_border_item_add(bd, 2);
+	       _src_border_item_add(p, bd, 2);
 	  }
      }
    e_container_border_list_free(bl);
 
-   if (eina_list_count(plugin.candidates) > 0)
+   if (eina_list_count(p->items) > 0)
      {
-	plugin.candidates = eina_list_sort(plugin.candidates,
-					   eina_list_count(plugin.candidates),
-					   _evry_plug_border_cb_sort);
+	p->items = eina_list_sort(p->items, eina_list_count(p->items),
+				  _src_border_cb_sort);
 	return 1;
      }
 
@@ -134,30 +184,28 @@
 }
 
 static void
-_evry_plug_border_item_icon_get( Evry_Item *it, Evas *e)
+_src_border_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
 { 
-   it->o_icon = e_border_icon_add(((E_Border *)it->data), e); 
+   it->o_icon = e_border_icon_add(((E_Border *)it->data[0]), e); 
 }
 
 static void
-_evry_plug_border_item_add(E_Border *bd, int prio)
+_src_border_item_add(Evry_Plugin *p, E_Border *bd, int prio)
 {
    Evry_Item *it;   
 
    it = calloc(1, sizeof(Evry_Item));
-   e_object_ref(E_OBJECT(bd));
-   it->data = bd;
+   /* e_object_ref(E_OBJECT(bd)); */
+   it->data[0] = bd;
    it->priority = prio;
    it->label = eina_stringshare_add(e_border_name_get(bd));
-   it->o_icon = NULL; //e_border_icon_add(bd, evry_evas_get()); 
 	     
-   plugin.candidates = eina_list_append(plugin.candidates, it);
+   p->items = eina_list_append(p->items, it);
 }
 
-
-// TODO sort by focus history and name?
+/* TODO sort by focus history and name? */
 static int
-_evry_plug_border_cb_sort(const void *data1, const void *data2)
+_src_border_cb_sort(const void *data1, const void *data2)
 {
    const Evry_Item *it1, *it2;
    
@@ -166,3 +214,122 @@
 
    return (it1->priority - it2->priority);
 }
+
+
+
+static Evry_Plugin *
+_act_border_new()
+{
+   Evry_Plugin *p;
+   Inst *inst;
+   
+   p = E_NEW(Evry_Plugin, 1);
+   p->class = &source;
+   p->begin = &_act_border_begin;
+   p->fetch = &_act_border_fetch;
+   p->action = &_act_border_action;
+   p->cleanup = &_act_border_cleanup;
+   p->icon_get = &_act_border_item_icon_get;
+   p->items = NULL;   
+
+   inst = E_NEW(Inst, 1);
+   p->priv = inst;
+   
+   return p;
+}
+
+static void
+_act_border_free(Evry_Plugin *p)
+{
+   Inst *inst = p->priv;
+
+   /* if (inst->border) e_object_unref(E_OBJECT(inst->border)); */
+
+   _act_border_cleanup(p);
+
+   E_FREE(p);
+   E_FREE(inst);
+}
+
+static void
+_act_cb_border_close(E_Border *bd)
+{
+   if (!bd->lock_close) e_border_act_close_begin(bd);
+}
+
+static void
+_act_cb_border_minimize(E_Border *bd)
+{
+   if (!bd->lock_user_iconify) e_border_iconify(bd);
+}
+
+static int
+_act_border_begin(Evry_Plugin *p, Evry_Item *item)
+{
+   Inst *inst = p->priv;
+   E_Border *bd;
+
+   bd = item->data[0];
+   /* e_object_ref(E_OBJECT(bd)); */
+   inst->border = bd;
+
+   return 1;
+}
+
+static int
+_act_border_fetch(Evry_Plugin *p, const char *input)
+{
+   _act_border_cleanup(p);
+
+   _act_border_item_add(p, _("Iconify"), _act_cb_border_minimize,
+			     "e/widgets/border/default/minimize");
+
+   _act_border_item_add(p, _("Close"), _act_cb_border_close,
+			     "e/widgets/border/default/close");
+   return 1;
+}
+
+static int
+_act_border_action(Evry_Plugin *p, Evry_Item *item, const char *input)
+{
+   Inst *inst = p->priv;
+   
+   void (*border_action) (E_Border *bd);
+   border_action = item->data[0];
+   border_action(inst->border);
+   return 1;
+}
+
+static void
+_act_border_cleanup(Evry_Plugin *p)
+{
+   Evry_Item *it;
+
+   EINA_LIST_FREE(p->items, it)
+     {
+	if (it->data[1]) eina_stringshare_del(it->data[1]);
+	if (it->label) eina_stringshare_del(it->label);
+	if (it->o_icon) evas_object_del(it->o_icon);
+	free(it);
+     }
+}
+
+static void
+_act_border_item_add(Evry_Plugin *p, const char *label, void (*action_cb) (E_Border *bd), const char *icon)
+{
+   Evry_Item *it;   
+
+   it = calloc(1, sizeof(Evry_Item));
+   it->data[0] = action_cb;
+   it->data[1] = (void *) eina_stringshare_add(icon);
+   it->label = eina_stringshare_add(label);
+   p->items = eina_list_append(p->items, it);   
+}
+
+static void
+_act_border_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
+{
+   it->o_icon = edje_object_add(e);
+   e_theme_edje_object_set(it->o_icon, "base/theme/borders", (const char *)it->data[1]);
+}
+
Index: e/src/modules/everything/evry.h
===================================================================
--- e/src/modules/everything/evry.h	(revision 41007)
+++ e/src/modules/everything/evry.h	(revision 41162)
@@ -4,6 +4,8 @@
 #ifdef E_TYPEDEFS
 
 typedef struct _Evry_Plugin Evry_Plugin;
+/* TODO find a better name - Registry ? */
+typedef struct _Evry_Plugin_Class Evry_Plugin_Class;
 typedef struct _Evry_Item   Evry_Item;
 typedef struct _Evry_Action Evry_Action;
 typedef struct _Evry_Config Evry_Config;
@@ -29,8 +31,12 @@
 struct _Evry_Item
 {
   const char *label;
+
+  const char *uri;
+  const char *mime;
+
+  /* set by icon_get plugin method */
   Evas_Object *o_icon;
-  unsigned int type;  /* TODO */
 
   /* used by 'everything' for display */
   Evas_Object *o_bg;  
@@ -38,55 +44,64 @@
   /* these are only for internally use by plugins */
   /* used e.g. as pointer for item data (Efreet_Desktop) or */
   /* for internal stuff, like priority hints for sorting, etc */
-  void *data;
+  void *data[4];
   int priority;
 };
 
-struct _Evry_Plugin
+struct _Evry_Plugin_Class
 {
   const char *name;
-  const char *type;
-  Evas_Object *o_icon;
+
+  const char *type_in;
+  const char *type_out;
+
+  /* TODO option */
+  int prio;
   
   /* sync/async ?*/
-  unsigned int async_query;
+  unsigned char async_query : 1;
 
   /* whether candidates can be shown without input: e.g. borders, history */
   /* if 0 fetch MUST provide all candidates when string is NULL */
-  // TODO better use 'need_query_length' ?
-  unsigned int need_query; 
+  unsigned char need_query : 1; 
 
-  /* run when 'everything' is shown */
-  void (*begin) (void);
+  Evry_Plugin *(*new) (void);
+  void (*free) (Evry_Plugin *p);
+  
+  Evas_Object *(*config_page) (void);
+  void (*config_apply) (void);
 
+  Eina_List *instances;
+};
+
+  
+struct _Evry_Plugin
+{
+  Evry_Plugin_Class *class;
+  
+  /* run when plugin is activated. */
+  int (*begin) (Evry_Plugin *p, Evry_Item *item);
+
   /* get candidates matching string, fills 'candidates' list */
-  int  (*fetch)  (char *string);
+  int  (*fetch) (Evry_Plugin *p, const char *input);
 
   /* run action with a given candidate - TODO register actions per
      candidate type */
-  int  (*action) (Evry_Item *item);
+  int  (*action) (Evry_Plugin *p, Evry_Item *item, const char *input);
 
   /* run before new query and when hiding 'everything' */
-  void (*cleanup) (void);
+  void (*cleanup) (Evry_Plugin *p);
 
-  void (*icon_get) (Evry_Item *it, Evas *e);  
+  void (*icon_get) (Evry_Plugin *p, Evry_Item *it, Evas *e);  
   /* provide more information for a candidate */
   /* int (*candidate_info) (Evas *evas, Evry_Item *item); */
 
-  Evas_Object *(*config_page) (void);
-  void (*config_apply) (void);
-  
-  /* Evry_Plugin_State state; */
-  Eina_List *candidates;
-};
+  Eina_List *items;
 
-struct _Evry_Action
-{
-  const char *name;
-  const char *type;
-  int  (*func) (Evry_Item *item);
-};
+  Evas_Object *tab;
   
+  void *priv;
+};  
 
 struct _Evry_Config
 {
@@ -108,12 +123,10 @@
 EAPI int  evry_show(E_Zone *zone);
 EAPI void evry_hide(void);
 
-EAPI void evry_plugin_add(Evry_Plugin *plugin);
-EAPI void evry_plugin_remove(Evry_Plugin *plugin);
-EAPI void evry_action_add(Evry_Action *action);
-EAPI void evry_action_remove(Evry_Action *action);
+EAPI void evry_plugin_register(Evry_Plugin_Class *pc);
+EAPI void evry_plugin_unregister(Evry_Plugin_Class *pc);
 
-/* EAPI void evry_plugin_async_update(Evry_Plugin *plugin, int state); */
+EAPI void evry_plugin_async_update(Evry_Plugin *plugin, int state);
 
 EAPI Evas* evry_evas_get(void);
 #endif
Index: e/src/modules/everything/evry_config.c
===================================================================
--- e/src/modules/everything/evry_config.c	(revision 0)
+++ e/src/modules/everything/evry_config.c	(revision 41162)
@@ -0,0 +1,134 @@
+#include "e.h"
+#include "e_mod_main.h"
+#include "evry.h"
+
+
+static void        *_create_data             (E_Config_Dialog *cfd);
+static void         _free_data               (E_Config_Dialog *cfd, E_Config_Dialog_Data *cfdata);
+static int          _basic_apply_data        (E_Config_Dialog *cfd, E_Config_Dialog_Data *cfdata);
+static Evas_Object *_basic_create_widgets    (E_Config_Dialog *cfd, Evas *evas, E_Config_Dialog_Data *cfdata);
+
+
+struct _E_Config_Dialog_Data 
+{
+  /* Basic */
+  int max_exe_list;
+  int max_eap_list;
+  int max_hist_list;
+  int scroll_animate;
+  /* Advanced */
+  double scroll_speed;
+  double pos_align_x;
+  double pos_align_y;
+  double pos_size_w;
+  double pos_size_h;
+  int pos_min_w;
+  int pos_min_h;
+  int pos_max_w;
+  int pos_max_h;
+  char *term_cmd;
+};
+
+
+E_Config_Dialog *
+e_int_config_exebuf(E_Container *con, const char *params __UNUSED__) 
+{
+   E_Config_Dialog *cfd;
+   E_Config_Dialog_View *v;
+   
+   if (e_config_dialog_find("E", "_config_everything_dialog")) return NULL;
+   v = E_NEW(E_Config_Dialog_View, 1);
+   
+   v->create_cfdata = _create_data;
+   v->free_cfdata = _free_data;
+   v->basic.apply_cfdata = _basic_apply_data;
+   v->basic.create_widgets = _basic_create_widgets;
+   v->advanced.apply_cfdata = NULL;
+   v->advanced.create_widgets = NULL;
+   cfd = e_config_dialog_new(con,
+			     _("Everything Settings"),
+			     "E", "_config_everything_dialog",
+			     "system-run", 0, v, NULL);
+   return cfd;
+}
+
+static void
+_fill_data(E_Config_Dialog_Data *cfdata) 
+{
+   /* Basic */
+   cfdata->max_exe_list = e_config->exebuf_max_exe_list;
+   cfdata->max_eap_list = e_config->exebuf_max_eap_list;
+   cfdata->max_hist_list = e_config->exebuf_max_hist_list;
+   cfdata->scroll_animate = e_config->exebuf_scroll_animate;
+   /* Advanced */
+   cfdata->scroll_speed = e_config->exebuf_scroll_speed;
+   cfdata->pos_align_x = e_config->exebuf_pos_align_x;
+   cfdata->pos_align_y = e_config->exebuf_pos_align_y;
+   cfdata->pos_size_w = e_config->exebuf_pos_size_w;
+   cfdata->pos_size_h = e_config->exebuf_pos_size_h;
+   cfdata->pos_min_w = e_config->exebuf_pos_min_w;
+   cfdata->pos_min_h = e_config->exebuf_pos_min_h;
+   cfdata->pos_max_w = e_config->exebuf_pos_max_w;
+   cfdata->pos_max_h = e_config->exebuf_pos_max_h;
+   if (e_config->exebuf_term_cmd)
+     cfdata->term_cmd = strdup(e_config->exebuf_term_cmd);
+}
+
+static void *
+_create_data(E_Config_Dialog *cfd) 
+{
+   E_Config_Dialog_Data *cfdata;
+   
+   cfdata = E_NEW(E_Config_Dialog_Data, 1);
+   _fill_data(cfdata);
+   return cfdata;
+}
+
+static void
+_free_data(E_Config_Dialog *cfd, E_Config_Dialog_Data *cfdata) 
+{
+   scroll_list = eina_list_free(scroll_list);
+
+   E_FREE(cfdata->term_cmd);
+   E_FREE(cfdata);
+}
+
+static int
+_basic_apply_data(E_Config_Dialog *cfd, E_Config_Dialog_Data *cfdata) 
+{
+   e_config->exebuf_max_exe_list = cfdata->max_exe_list;
+   e_config->exebuf_max_eap_list = cfdata->max_eap_list;
+   e_config->exebuf_max_hist_list = cfdata->max_hist_list;
+   e_config->exebuf_scroll_animate = cfdata->scroll_animate;
+   e_config_save_queue();
+   return 1;
+}
+
+static Evas_Object *
+_basic_create_widgets(E_Config_Dialog *cfd, Evas *evas, E_Config_Dialog_Data *cfdata) 
+{
+   Evas_Object *o, *of, *ob;
+   
+   o = e_widget_list_add(evas, 0, 0);
+
+   of = e_widget_framelist_add(evas, _("General Settings"), 0);
+   ob = e_widget_label_add(evas, _("Maximum Number of Matched Apps to List"));
+   e_widget_framelist_object_append(of, ob);
+   ob = e_widget_slider_add(evas, 1, 0, _("%1.0f"), 10, 50, 5, 0, NULL, &(cfdata->max_eap_list), 200);
+   e_widget_framelist_object_append(of, ob);   
+   ob = e_widget_label_add(evas, _("Maximum Number of Matched Exes to List"));
+   e_widget_framelist_object_append(of, ob);
+   ob = e_widget_slider_add(evas, 1, 0, _("%1.0f"), 10, 50, 5, 0, NULL, &(cfdata->max_exe_list), 200);
+   e_widget_framelist_object_append(of, ob);   
+   ob = e_widget_label_add(evas, _("Maximum History to List"));
+   e_widget_framelist_object_append(of, ob);
+   ob = e_widget_slider_add(evas, 1, 0, _("%1.0f"), 10, 200, 5, 0, NULL, &(cfdata->max_hist_list), 200);
+   e_widget_framelist_object_append(of, ob);   
+   e_widget_list_object_append(o, of, 1, 1, 0.5);   
+   
+   of = e_widget_framelist_add(evas, _("Scroll Settings"), 0);
+   ob = e_widget_check_add(evas, _("Scroll Animate"), &(cfdata->scroll_animate));
+   e_widget_framelist_object_append(of, ob);
+   e_widget_list_object_append(o, of, 1, 1, 0.5);
+   return o;
+}
Index: e/src/modules/everything/evry_plug_dir_browse.c
===================================================================
--- e/src/modules/everything/evry_plug_dir_browse.c	(revision 0)
+++ e/src/modules/everything/evry_plug_dir_browse.c	(revision 41162)
@@ -0,0 +1,276 @@
+#include "e.h"
+#include "e_mod_main.h"
+
+typedef struct _Inst Inst;
+
+struct _Inst
+{
+  const char *directory;
+};
+
+static Evry_Plugin *_plug_new();
+static void _plug_free(Evry_Plugin *p);
+static int  _begin(Evry_Plugin *p, Evry_Item *item);
+static int  _fetch(Evry_Plugin *p, const char *input);
+static int  _action(Evry_Plugin *p, Evry_Item *item, const char *input);
+static void _cleanup(Evry_Plugin *p);
+static int  _cb_sort(const void *data1, const void *data2);
+static void _item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e);
+static void _list_free(Evry_Plugin *p);
+static Evry_Item *_item_fill(const char *directory, const char *file);
+
+static Evry_Plugin_Class class;
+
+EAPI int
+evry_plug_dir_browse_init(void)
+{
+   class.name = "Browse Files";
+   class.type_in  = "NONE|FILE";
+   class.type_out = "FILE";
+   class.prio = 2;
+   class.new = &_plug_new;
+   class.free = &_plug_free;
+   evry_plugin_register(&class);
+
+   return 1;
+}
+
+EAPI int
+evry_plug_dir_browse_shutdown(void)
+{
+   evry_plugin_unregister(&class);
+   
+   return 1;
+}
+
+static Evry_Plugin *
+_plug_new()
+{
+   Evry_Plugin *p = E_NEW(Evry_Plugin, 1);
+   p->class = &class;
+   p->begin = &_begin;
+   p->fetch = &_fetch;
+   p->action = &_action;
+   p->cleanup = &_cleanup;
+   p->icon_get = &_item_icon_get;
+   p->items = NULL;   
+
+   Inst *inst = E_NEW(Inst, 1);
+   inst->directory = eina_stringshare_add(e_user_homedir_get());
+   p->priv = inst;
+
+   return p;
+}
+
+static void
+_plug_free(Evry_Plugin *p)
+{
+   _cleanup(p);
+
+   Inst *inst = p->priv;
+   eina_stringshare_del(inst->directory);
+   E_FREE(inst);
+   E_FREE(p);
+}
+
+
+static int
+_action(Evry_Plugin *p, Evry_Item *item, const char *input)
+{   
+   return 0;
+}
+
+static void
+_list_free(Evry_Plugin *p)
+{
+   Evry_Item *it;
+
+   EINA_LIST_FREE(p->items, it)
+     {
+	if (it->label) eina_stringshare_del(it->label);
+	if (it->uri) eina_stringshare_del(it->uri);
+	if (it->mime) eina_stringshare_del(it->mime);
+	if (it->o_icon) evas_object_del(it->o_icon);
+
+	free(it);
+     }
+}
+
+
+static void
+_cleanup(Evry_Plugin *p)
+{
+   _list_free(p);
+}
+
+static int
+_begin(Evry_Plugin *p, Evry_Item *item)
+{
+   Inst *inst = p->priv;
+   
+   if (item->uri && ecore_file_is_dir(item->uri))
+     {
+	eina_stringshare_del(inst->directory);
+	inst->directory = eina_stringshare_add(item->uri);
+	
+	return 1;
+     }
+
+   return 0;
+}
+
+/* based on directory-watcher from drawer module  */
+static int
+_fetch(Evry_Plugin *p, const char *input)
+{
+   Eina_List *files;
+   char *file;
+   Evry_Item *it;
+   char match1[4096];
+   char match2[4096];
+   Inst *inst = p->priv;
+   
+   _list_free(p);
+   
+   files = ecore_file_ls(inst->directory);
+
+   if (input)
+     {
+	snprintf(match1, sizeof(match1), "%s*", input);
+	snprintf(match2, sizeof(match2), "*%s*", input);
+     }
+
+   EINA_LIST_FREE(files, file)
+     {
+	it = NULL;
+	
+	if (file[0] == '.') goto end;
+	
+	if (input)
+	  {
+	     if (e_util_glob_case_match(file, match1))
+	       {
+		  it  = _item_fill(inst->directory, file);
+		  it->priority += 1;
+	       }
+	     else if (e_util_glob_case_match(file, match2))
+	       {
+		  it = _item_fill(inst->directory, file);
+	       }
+	  }
+	else
+	  {
+	     it  = _item_fill(inst->directory, file);
+	  }
+	
+	if (it)
+	  p->items = eina_list_append(p->items, it);
+
+     end:
+	free(file);
+
+     }
+
+   if (eina_list_count(p->items) > 0)
+     {
+	p->items = eina_list_sort(p->items, eina_list_count(p->items),
+				  _cb_sort);
+	return 1;
+     }
+
+   return 0;
+}
+
+/* based on directory-watcher from drawer module  */
+static Evry_Item *
+_item_fill(const char *directory, const char *file)
+{
+   Evry_Item *it = NULL;
+   char buf[4096];
+   const char *mime, *file_path;
+
+   it = E_NEW(Evry_Item, 1);
+
+   snprintf(buf, sizeof(buf), "%s/%s", directory, file);
+   
+   if ((e_util_glob_case_match(file, "*.desktop")) ||
+       (e_util_glob_case_match(file, "*.directory")))
+     {
+	Efreet_Desktop *desktop;
+
+	desktop = efreet_desktop_new(buf);
+	if (!desktop) return NULL;
+	it->label = eina_stringshare_add(desktop->name);
+	efreet_desktop_free(desktop);
+     }
+   else
+     it->label = eina_stringshare_add(file);
+
+   file_path = eina_stringshare_add(buf);
+
+   it->uri = file_path;
+   
+   mime = efreet_mime_globs_type_get(file_path);
+   if (mime)
+     {
+	it->mime = eina_stringshare_add(mime);
+	it->priority = 0;
+     }
+   else if (ecore_file_is_dir(file_path))
+     {
+	it->mime = eina_stringshare_add("Folder");
+	it->priority = 1;
+     }
+   else if ((mime = efreet_mime_type_get(file_path)))
+     {
+	it->mime = eina_stringshare_add(mime);
+	it->priority = 0;
+     }
+   else	
+     {
+	it->mime = eina_stringshare_add("None");
+	it->priority = 0;
+     }
+   
+   return it;
+}
+
+static void
+_item_icon_get(Evry_Plugin *p, Evry_Item *it, Evas *e)
+{
+   char *item_path;
+
+   if (!it->mime) return;
+   
+   if (!strcmp(it->mime, "Folder"))
+     {
+	it->o_icon = edje_object_add(e);
+	e_theme_edje_object_set(it->o_icon, "base/theme/fileman", "e/icons/folder");
+     }
+   else
+     {
+	item_path = efreet_mime_type_icon_get(it->mime, e_config->icon_theme, 32);
+
+	if (item_path)
+	  it->o_icon = e_util_icon_add(item_path, e);
+	else
+	  {
+	     it->o_icon = edje_object_add(e);
+	     e_theme_edje_object_set(it->o_icon, "base/theme/fileman", "e/icons/fileman/file");
+	  }
+     }
+}
+
+static int
+_cb_sort(const void *data1, const void *data2)
+{
+   const Evry_Item *it1, *it2;
+   
+   it1 = data1;
+   it2 = data2;
+
+   if (it2->priority - it1->priority) 
+     return (it2->priority - it1->priority);
+   else
+     return strcasecmp(it1->label, it2->label);
+}
Index: e/src/modules/everything/e_mod_main.h
===================================================================
--- e/src/modules/everything/e_mod_main.h	(revision 41007)
+++ e/src/modules/everything/e_mod_main.h	(revision 41162)
@@ -25,6 +25,8 @@
 
   int scroll_animate;
   double scroll_speed;
+
+  int auto_select_first;
 };
 
 struct _Source_Config
@@ -52,6 +54,12 @@
 EAPI int  evry_plug_config_init(void);
 EAPI int  evry_plug_config_shutdown(void);
 
+EAPI int  evry_plug_tracker_init(void);
+EAPI int  evry_plug_tracker_shutdown(void);
+
+EAPI int  evry_plug_dir_browse_init(void);
+EAPI int  evry_plug_dir_browse_shutdown(void);
+
 extern Config *evry_conf;
 
 #endif
